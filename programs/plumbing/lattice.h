#ifndef LATTICE_H
#define LATTICE_H

#include <iostream>
#include <fstream>
#include <array>
#include <vector>


// TODO: assertion moved somewhere where basic params
#undef NDEBUG
#include <assert.h>
#include "../plumbing/defs.h"
#include "../plumbing/coordinates.h"
#include "../plumbing/inputs.h"



struct node_info {
  coordinate_vector min,size;
  unsigned evensites, oddsites;
};

/* Some backends need specialized lattice data
 * in loops. Forward declaration here and
 * implementations in backend headers.
 * Loops generated by Transformer can access
 * this through lattice->backend_lattice.
 */
struct backend_lattice_struct;






class lattice_struct {
private:
 
  // Use ints instead of unsigned, just to avoid surprises in arithmetics
  // I shall assume here that int is 32 bits, and long long 64 bits.  I guess these are
  // pretty much standard for now
  // Alternative: int_32t and int_64t (or int_fast_32t  and int_fast_64t, even more generally) 
  coordinate_vector l_size;
  long long l_volume;

  // Information about the node stored on this process
  struct node_struct {
    int rank;                           // rank of this node
    unsigned sites, evensites, oddsites;
    unsigned field_alloc_size;          // how many sites/node in allocations 
    coordinate_vector min, size;        // node local coordinate ranges
    unsigned nn[NDIRS];                 // nn-node of node down/up to dirs
    bool first_site_even;               // is location min even or odd?
    std::vector<coordinate_vector> coordinates;

    void setup(node_info & ni, lattice_struct & lattice);
  } this_node;

  // information about all nodes
  struct allnodes {
    int number;                            // number of nodes
    unsigned n_divisions[NDIM];            // number of node divisions to dir
    // lattice division: div[d] will have num_dir[d]+1 elements, last size
    // TODO: is this needed at all?
    std::vector<unsigned> divisors[NDIM];
    std::vector<node_info> nodelist;

    unsigned * RESTRICT map_array;                  // mapping (optional)
    unsigned * RESTRICT map_inverse;                // inv of it
    
    void create_remap();                   // create remap_node
    unsigned remap(unsigned i);            // use remap
    unsigned inverse_remap(unsigned i);    // inverse remap
    
  } nodes;

public:

  struct comm_node_struct {
    unsigned rank;                         // rank of communicated with node
    unsigned sites, evensites, oddsites;
    unsigned buffer;
    std::vector<unsigned> sitelist;

    // The number of sites that need to be communicated
    unsigned n_sites(parity par){
      if(par == ALL){
        return sites;
      } else if(par == EVEN){
        return evensites;
      } else {
        return oddsites;
      }
    }

    // The local index of a site that is sent to neighbour
    unsigned site_index(int site, parity par){
      if(par == ODD){
        return sitelist[evensites+site];
      } else {
        return sitelist[site];
      }
    }

    // The offset of the halo from the start of the field array
    unsigned offset(parity par){
      if(par == ODD){
        return buffer + evensites;
      } else {
        return buffer;
      }
    }
  };

  struct comminfo_struct {
    unsigned * index;
    std::vector<comm_node_struct> from_node;
    std::vector<comm_node_struct> to_node;
    unsigned receive_buf_size;                    // only for general gathers
  };

  // nearest neighbour comminfo struct
  comminfo_struct comminfo[NDIRS];

  


  unsigned * RESTRICT neighb[NDIRS];
  unsigned char * RESTRICT wait_arr_;

  backend_lattice_struct *backend_lattice;

  void setup(int siz[NDIM], int &argc, char **argv);
  void setup(input & inputs);
  void setup_layout();
  void setup_nodes();
  
  #if NDIM == 4
  void setup(int nx, int ny, int nz, int nt, int &argc, char **argv);
  #elif NDIM == 3  
  void setup(int nx, int ny, int nz, int &argc, char **argv);
  #elif NDIM == 2
  void setup(int nx, int ny, int &argc, char **argv);
  #elif NDIM == 1
  void setup(int nx, int &argc, char **argv); 
  #endif


  void teardown();

  int size(direction d) { return l_size[d]; }
  int size(int d) { return l_size[d]; }
  coordinate_vector size() {return l_size;}

  int local_size(int d) { return this_node.size[d]; }
  long long volume() { return l_volume; }
  int node_rank() { return this_node.rank; }
  int n_nodes() { return nodes.number; }
  long long local_volume() {return this_node.sites;}
  
  bool is_on_node(const coordinate_vector & c);
  int  node_rank(const coordinate_vector & c);
  unsigned site_index(const coordinate_vector & c);
  unsigned site_index(const coordinate_vector & c, const unsigned node);
  coordinate_vector site_coordinates(unsigned index);
  unsigned field_alloc_size() {return this_node.field_alloc_size; }

  void create_std_gathers();
  comminfo_struct create_general_gather( const coordinate_vector & r);
  std::vector<comm_node_struct> 
  create_comm_node_vector( coordinate_vector offset, unsigned * index, bool receive);

  
  bool first_site_even() { return this_node.first_site_even; };

  unsigned remap_node(const unsigned i);
  
  #ifdef EVEN_SITES_FIRST
  int loop_begin( parity P) const {
    if(P==ODD){
      return this_node.evensites;
    } else {
      return 0;
    }
  }
  int loop_end( parity P) const {
    if(P==EVEN){
      return this_node.evensites;
    } else {
      return this_node.sites;
    }
  }
  #else
  
  int loop_begin( parity P) const {
    if(P==EVEN){
      return this_node.evensites;
    } else {
      return 0;
    }
  }
  int loop_end( parity P) const {
    if(P==ODD){
      return this_node.evensites;
    } else {
      return this_node.sites;
    }
  }
  #endif

  coordinate_vector coordinates( unsigned idx ){
    return site_coordinates(idx);
  }

  coordinate_vector local_coordinates( unsigned idx ){
    coordinate_vector l = site_coordinates(idx);
    foralldir(d)
      l[d] = l[d] - this_node.min[d];
    return l;
  }

  lattice_struct::comminfo_struct get_comminfo(int d){
    return comminfo[d];
  }

  /* MPI functions and variables. Define here in lattice? */
  void initialize_wait_arrays();
  #ifdef USE_MPI
  MPI_Comm mpi_comm_lat;
  #endif

  template <typename T>
  void reduce_node_sum(T * value, int N, bool distribute);

  template <typename T>
  void reduce_node_product(T * value, int N, bool distribute);

  // Guarantee 64 bits for these - 32 can overflow!
  unsigned long long n_gather_done = 0, n_gather_avoided = 0;

};

/// global handle to lattice
extern lattice_struct * lattice;


// Keep track of defined lattices
extern std::vector<lattice_struct*> lattices;





#ifdef VANILLA
#include "../plumbing/backend_cpu/lattice.h"
#elif defined(CUDA)
#include "../plumbing/backend_cuda/lattice.h"
#elif defined(VECTORIZED)
#include "../plumbing/backend_vector/lattice.h"
#endif




#endif

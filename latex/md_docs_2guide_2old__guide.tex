\chapter{Snippets of important information.}
\hypertarget{md_docs_2guide_2old__guide}{}\label{md_docs_2guide_2old__guide}\index{Snippets of important information.@{Snippets of important information.}}
Old guide. Saving for if there is some useful guidance here or important informtion to add to the new guide.\hypertarget{md_docs_2guide_2old__guide_autotoc_md6}{}\doxysection{\texorpdfstring{Syntax -\/ What works}{Syntax - What works}}\label{md_docs_2guide_2old__guide_autotoc_md6}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md7}{}\doxysubsection{\texorpdfstring{Single line statements}{Single line statements}}\label{md_docs_2guide_2old__guide_autotoc_md7}
You can operate on fields using statements like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{my\_field[ALL]\ =\ my\_other\_field[X]\ +\ my\_third\_field[X];}

\end{DoxyCode}
 On the left-\/hand side of the statement you should specify either {\ttfamily \mbox{[}ALL\mbox{]}} lattice sites, {\ttfamily \mbox{[}EVEN\mbox{]}} sites or {\ttfamily \mbox{[}ODD\mbox{]}} sites. The statement will apply only to this collection of sites. On the right hand side, use {\ttfamily \mbox{[}X\mbox{]}} to refer to this collection of sites.

You can refer to neighbouring sites by adding a Direction ({\ttfamily e\+\_\+x}, {\ttfamily -\/e\+\_\+x}, {\ttfamily e\+\_\+y}, {\ttfamily -\/e\+\_\+y}, {\ttfamily e\+\_\+z}, {\ttfamily -\/e\+\_\+z}, {\ttfamily e\+\_\+t}, {\ttfamily -\/e\+\_\+t}, ...)\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{my\_field[EVEN]\ =\ my\_field[X+e\_y];}

\end{DoxyCode}


You can also operate on fields directly, 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{my\_field\ =\ my\_field\ +\ 1;}

\end{DoxyCode}
 This will operate on all sites and is equivalent to 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{my\_field[ALL]\ =\ my\_field[X]\ +\ 1;}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md9}{}\doxysubsection{\texorpdfstring{General loops}{General loops}}\label{md_docs_2guide_2old__guide_autotoc_md9}
Loops over all sites or a parity\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{forsites(ALL)\{\}}
\DoxyCodeLine{forsites(EVEN)\{\}}
\DoxyCodeLine{forsites(ODD)\{\}}

\end{DoxyCode}
 Inside the loop, refer to the sites using X\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{forsites(ALL)\{}
\DoxyCodeLine{\ \ \ \ my\_field[X]\ =\ 1;}
\DoxyCodeLine{\}}

\end{DoxyCode}


As before, you can refer to neighbouring sites by adding a Direction\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{forsites(EVEN)\{}
\DoxyCodeLine{\ \ \ \ my\_field[X]\ =\ my\_field[X+e\_y];}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md10}{}\doxysection{\texorpdfstring{What doesn\textquotesingle{}t work (as expected)}{What doesn't work (as expected)}}\label{md_docs_2guide_2old__guide_autotoc_md10}
Functions that implicitly depend on the site and return a number. For example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{forsites(EVEN)\{}
\DoxyCodeLine{\ \ \ \ matrix\_field[X].gaussian();}
\DoxyCodeLine{\}}

\end{DoxyCode}
 runs incorrectly with AVX. It does not actually run once for each site, but only once for each vector.\hypertarget{md_docs_2guide_2old__guide_autotoc_md11}{}\doxysection{\texorpdfstring{Extensions}{Extensions}}\label{md_docs_2guide_2old__guide_autotoc_md11}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md12}{}\doxysubsection{\texorpdfstring{HMC}{HMC}}\label{md_docs_2guide_2old__guide_autotoc_md12}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md13}{}\doxysubsubsection{\texorpdfstring{Gauge field}{Gauge field}}\label{md_docs_2guide_2old__guide_autotoc_md13}
The gauge field class is mainly a convenient wrapper containing a matrix field for each Direction. It allows us to refer to the gauge field as {\ttfamily gauge\+\_\+field\texorpdfstring{$<$}{<}SUN\texorpdfstring{$>$}{>} U} rather than {\ttfamily SUN U\mbox{[}NDIM\mbox{]}}, which is inconvenient to pass as a reference.

The gauge fields also contains a momentum field. Since fields are only allocated if necessary, this is not a large amount of data. Fundamental gauge fields can also store a copy of the gauge field for HMC.\hypertarget{md_docs_2guide_2old__guide_autotoc_md14}{}\doxysubsubsection{\texorpdfstring{Actions}{Actions}}\label{md_docs_2guide_2old__guide_autotoc_md14}
Actions represent terms in the full action of a quantum field theory and are used to set up the HMC simulation. Each action implements at least


\begin{DoxyEnumerate}
\item {\ttfamily double action()}\+: returns the current value of the action
\item {\ttfamily void force\+\_\+step()}\+: calculates the derivative and updates canonical momenta
\item {\ttfamily void draw\+\_\+gaussian\+\_\+fields()}\+: draws random values for any gaussian fields
\item {\ttfamily void backup\+\_\+fields()}\+: make a backup of gauge fields at the beginning of HMC
\item {\ttfamily void restore\+\_\+backup()}\+: restore the original field from the backup if the update is rejected
\end{DoxyEnumerate}

For example, the gauge action represents the Wilson plaquette action  \[
    S_{gauge} = \sum_x \beta\left [ 1 - Re \sum_{\mu>\nu} U_{x,\mu} U_{x+\mu,\nu} U^\dagger_{x+\nu, \mu} U^\dagger_{x,\nu} \right ]
\]

The fermion action represents the pseudo fermion action  \[
    S_{fermion} = e^{-\sum_{x,y} \chi_x^\dagger \left(\frac{1}{D^\dagger D}\right)_{x,y} \chi_y}.
\] The Dirac operator can be any of the implemented Wilson Dirac operator, the even-\/odd preconditioned Wilson Dirac operator, the staggered Dirac operator or the even-\/odd preconditioned staggered Dirac operator. See operators below for more detail about how these and the matrix inversion are used.

At small mass it is often more efficient to split the fermion determinant  \[
    Z_{fermion} = \int d\chi e^{-S_{fermion}} = det\left( D^\dagger D \right)
\] to  \[
    det\left( D^\dagger D \right) = det\left( (D + m)^\dagger (D + m) \right)
    det\left( \frac{ D^\dagger D }{(D + m)^\dagger (D + m)} \right)
\] To use this, you need two actions, Hasenbusch action 1 and Hasenbusch action 2.\hypertarget{md_docs_2guide_2old__guide_autotoc_md15}{}\doxysubsubsection{\texorpdfstring{Integrators}{Integrators}}\label{md_docs_2guide_2old__guide_autotoc_md15}
An integrator updates the gauge fields and their canonical momenta keeping the action approximately constant. Two integrators are defined, the leapfrog and the O2 (aka Omelyan) integrators.

Integrators are constructed from an action term and a lower level integrator (or the momentum action on the lowest level). An integrator step updates the gauge field keeping the action approximately constant.

Integrators form a hierarchy, where lowest levels are run more often in a trajectory. The momentum action is also an integrator and forms the lowest level. Generally the force of the gauge action is fast to calculate and should be added second. The fermion action is the most expensive due to the inversion of the Dirac matrix and should be added on a high level.

The leapfrog integrator requires a single evaluation of the derivative of the action term and conserves the action to second order in the step size. The O2 integrator conserves the action to the third order in the, but requires two evaluations.\hypertarget{md_docs_2guide_2old__guide_autotoc_md16}{}\doxysubsubsection{\texorpdfstring{Full HMC}{Full HMC}}\label{md_docs_2guide_2old__guide_autotoc_md16}
The full process of setting up HMC is 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{//\ First\ define\ a\ gauge\ field}
\DoxyCodeLine{gauge\_field<SU<N,\ double>>\ gauge;}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Let's\ just\ start\ from\ unity}
\DoxyCodeLine{gauge.set\_unity();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Set\ up\ the\ action\ of\ the\ gauge\ and\ momentum\ actions}
\DoxyCodeLine{gauge\_action\ ga(gauge,\ beta);}
\DoxyCodeLine{gauge\_momentum\_action\ ma(gauge);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Set\ up\ the\ first\ level\ in\ the\ intergator\ hierarchy}
\DoxyCodeLine{O2\_integrator\ integrator\_level\_1(ga,\ ma);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Define\ the\ Dirac\ operator}
\DoxyCodeLine{dirac\_staggered\_evenodd\ D(mass,\ gauge);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ and\ the\ fermion\ action}
\DoxyCodeLine{fermion\_action\ fa(D,\ gauge);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ and\ finally\ the\ second\ level\ of\ the\ integrator}
\DoxyCodeLine{O2\_integrator\ integrator\_level\_2(fsum,\ integrator\_level\_1);}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Now\ we\ can\ run\ an\ HMC\ trajectory}
\DoxyCodeLine{update\_hmc(integrator\_level\_2,\ hmc\_steps,\ traj\_length);}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md17}{}\doxysubsection{\texorpdfstring{Operators}{Operators}}\label{md_docs_2guide_2old__guide_autotoc_md17}
Operators are classes that define an {\ttfamily apply(Field\texorpdfstring{$<$}{<}type\texorpdfstring{$>$}{>} input, Field\texorpdfstring{$<$}{<}type\texorpdfstring{$>$}{>} output)} method. The method takes the a field and runs a transformation on it, returning the result in the output field.

The Wilson Dirac and staggered Dirac operators are defined in libraries/dirac. They implement the two most common lattice Dirac operators. These files also have the even-\/odd preconditioned versions of these operators.

The Dirac operators also have a {\ttfamily dagger(Field\texorpdfstring{$<$}{<}type\texorpdfstring{$>$}{>} input, Field\texorpdfstring{$<$}{<}type\texorpdfstring{$>$}{>} output)} method, which implements the conjugate of the operator.

The conjugate gradient operator calculates the inverse of the square of an operator applied to a vector  \[
    out = CG(D) in = \frac{1}{D^\dagger D} in.
\] In is defined in libraries/dirac/conjugate\+\_\+gradient.\+h

Note that the Hasenbusch preconditioned operator in libraries/dirac/conjugate\+\_\+gradient.\+h is a utility class used in the Hasenbusch action.\hypertarget{md_docs_2guide_2old__guide_autotoc_md18}{}\doxysection{\texorpdfstring{Testing}{Testing}}\label{md_docs_2guide_2old__guide_autotoc_md18}
In the {\ttfamily programs/test\+\_\+cases} folder you can find a collection of simple test programs. To test whether the translations work on the cpu, type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ bash}
\DoxyCodeLine{./test.sh\ }

\end{DoxyCode}


This tests the transform, compilation and run process for the test\+\_\+\texorpdfstring{$\ast$}{*}.cpp files for dimensions from 1 to 4, and outputs the exit status of each step. If you\textquotesingle{}re on a machine with GPU\textquotesingle{}s, you can test the GPU transformations with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ bash}
\DoxyCodeLine{./test\_GPU.sh}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md19}{}\doxysection{\texorpdfstring{OLD HILA README}{OLD HILA README}}\label{md_docs_2guide_2old__guide_autotoc_md19}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md20}{}\doxysection{\texorpdfstring{Overview}{Overview}}\label{md_docs_2guide_2old__guide_autotoc_md20}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md21}{}\doxysubsection{\texorpdfstring{A simple hila application}{A simple hila application}}\label{md_docs_2guide_2old__guide_autotoc_md21}

\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{\#include\ "{}hila.h"{}}
\DoxyCodeLine{static\_assert(NDIM\ ==\ 3,\ "{}NDIM\ must\ be\ 3"{});}
\DoxyCodeLine{}
\DoxyCodeLine{int\ main(int\ argc,\ char\ *\ argv[])\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ hila::initialize(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ set\ up\ 32\string^3\ lattice}
\DoxyCodeLine{\ \ \ \ lattice.setup(\{32,32,32\});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Random\ numbers\ are\ used\ here}
\DoxyCodeLine{\ \ \ \ hila::seed\_random(32345);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ Field<Complex<double>>\ f;}
\DoxyCodeLine{\ \ \ \ Field<double>\ g\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ make\ f\ Gaussian\ random\ distributed}
\DoxyCodeLine{\ \ \ \ onsites(ALL)\ f[X].gaussian();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ calculate\ sum\ of\ 2nd\ derivatives\ of\ f\ to\ g}
\DoxyCodeLine{\ \ \ \ foralldir(d)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ g[ALL]\ +=\ abs(f[X+d]\ -\/\ 2*f[X]\ +\ f[X-\/d]);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ get\ average\ of\ g}
\DoxyCodeLine{\ \ \ \ double\ ave\ =\ 0;}
\DoxyCodeLine{\ \ \ \ onsites(ALL)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ave\ +=\ g[X];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ hila::out0\ <<\ "{}Average\ of\ g\ is\ "{}\ <<\ ave/lattice.volume()\ <<\ '\(\backslash\)n';}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ make\ a\ clean\ exit}
\DoxyCodeLine{\ \ \ \ hila::finishrun();\ \ \ \ }
\DoxyCodeLine{\}}

\end{DoxyCode}
 You can compile this at {\ttfamily hila/applications/hila\+\_\+example/} with {\ttfamily make simple} and run it with {\ttfamily build/simple}\hypertarget{md_docs_2guide_2old__guide_autotoc_md22}{}\doxysubsection{\texorpdfstring{Datatypes}{Datatypes}}\label{md_docs_2guide_2old__guide_autotoc_md22}

\begin{DoxyItemize}
\item NDIM\+: number of dimensions, values 2,3,4 (TODO\+: NDIM=1?). Typically set in application Makefile
\item Standard types\+: {\ttfamily int}, {\ttfamily int64\+\_\+t}, {\ttfamily float}, {\ttfamily double} ({\ttfamily long double}?)
\item Hila provided basic types\+: {\ttfamily Complex\textbackslash{}\texorpdfstring{$<$}{<}S\textbackslash{}\texorpdfstring{$>$}{>}}, {\ttfamily Vector\textbackslash{}\texorpdfstring{$<$}{<}n,T\textbackslash{}\texorpdfstring{$>$}{>}}, {\ttfamily Matrix\textbackslash{}\texorpdfstring{$<$}{<}n,m,T\textbackslash{}\texorpdfstring{$>$}{>}}, {\ttfamily Square\+Matrix\textbackslash{}\texorpdfstring{$<$}{<}n,T\textbackslash{}\texorpdfstring{$>$}{>}}, {\ttfamily Array\textbackslash{}\texorpdfstring{$<$}{<}n,m,T\textbackslash{}\texorpdfstring{$>$}{>}}

Here S is any standard type, and T includes S and Complex\texorpdfstring{$<$}{<}S\texorpdfstring{$>$}{>}. C++ or C standard complex types should not be used (not AVX vectorizable). See docs for functions/methods (TODO Doxygen docs)
\item Special types\+:
\begin{DoxyItemize}
\item {\ttfamily Parity}\+: enum with values EVEN, ODD, ALL; refers to parity of the site. Parity of site (x,y,z,t) is even if {\ttfamily (x+y+z+t)} is even, odd otherwise.
\item {\ttfamily Direction}\+: conceptually unit vector with values {\ttfamily ±e\+\_\+x, ±e\+\_\+y, ±e\+\_\+z, ±e\+\_\+t} (if NDIM==4). Implemented as an enum class. Can be used to index arrays of size NDIM.
\item {\ttfamily Coordinate\+Vector}\+: derived from Vector$<$\+NDIM,int$>$.

Direction variable acts as an unit vector in vector algebra\+: (assume below NDIM=4)
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{C++\ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ CoordinateVector\ v;}
\DoxyCodeLine{\ \ \ \ Direction\ d\ =\ e\_x;}
\DoxyCodeLine{\ \ \ \ v\ =\ d;\ \ \ \ \ \ \ \ \ \ \ \ \ //\ v\ =\ [1,0,0,0]}
\DoxyCodeLine{\ \ \ \ v\ +=\ e\_y\ -\/\ 3*d;\ \ \ \ //\ v\ =\ [-\/2,1,0,0]}
\DoxyCodeLine{\ \ \ \ v\ =\ \{0,1,-\/1,0\};\ \ \ \ //\ v\ =\ [0,1,-\/1,0]\ equivalent\ v\ =\ e\_y\ -\/\ e\_z;}
\DoxyCodeLine{\ \ \ \ hila::out0\ <<\ v.dot(\{1,2,3,4\});\ \ //\ dot\ product\ of\ 2\ vectors,\ prints\ -\/1}
\DoxyCodeLine{\ \ \ \ int\ j\ =\ d;\ \ \ \ \ \ \ \ \ //\ ok}
\DoxyCodeLine{\ \ \ \ d\ =\ j;\ \ \ \ \ \ \ \ \ \ \ \ \ //\ ERROR:\ cannot\ assign\ int\ to\ Direction}
\DoxyCodeLine{\ \ \ \ ++d;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ e\_x\ -\/>\ e\_y}
\DoxyCodeLine{\ \ \ \ is\_up\_dir(d);\ \ \ \ \ \ //\ true\ if\ d\ is\ along\ positive\ x,y,z,t\ -\/dir.}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md23}{}\doxysubsection{\texorpdfstring{Field access and traversal}{Field access and traversal}}\label{md_docs_2guide_2old__guide_autotoc_md23}
The principal traversal of the lattice is with {\itshape site loops} {\ttfamily onsites(\+Parity)}, and a special location identifier {\ttfamily X} (effectively a new keyword). ~\newline



\begin{DoxyCode}{0}
\DoxyCodeLine{C++}
\DoxyCodeLine{\ \ using\ mytype\ =\ Matrix<3,3,Complex<double>>;\ \ \ //\ use\ type\ alias}
\DoxyCodeLine{\ \ Field<mytype>\ f,g,h;}
\DoxyCodeLine{\ \ .\ .\ .}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ onsites(ALL)\ f[X]\ =\ 2\ +\ g[X];\ \ \ \ \ \ \ \ \ \ //\ 2\ acts\ as\ 2*I\ for\ square\ matrices}
\DoxyCodeLine{\ \ f[ALL]\ =\ 2\ +\ g[X];\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ equivalent\ shorter\ form\ for\ simple\ 1-\/line\ assignments}
\DoxyCodeLine{\ \ f\ =\ 2\ +\ g;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ this\ is\ also\ equivalent!}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ parity\ p\ =\ EVEN;}
\DoxyCodeLine{\ \ Direction\ d\ =\ e\_x;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ onsites(p)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ auto\ t\ =\ g[X\ +\ d];\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ X\ +-\/\ Direction\ fetches\ from\ neighbour\ site}
\DoxyCodeLine{\ \ \ \ \ \ f[X]\ +=\ t\ +\ t*t;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ can\ define\ variables\ in\ the\ loop\ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ h[X]\ =\ g[X\ +\ e\_x\ -\/\ 2*e\_y];\ \ \ \ \ \ \ \ \ //\ non-\/nearest\ neighbour\ fetch\ (TODO:optimize!)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ if\ (X.coordinate(e\_t)\ ==\ 0)\ \{\ \ \ \ \ \ //\ Do\ this\ on\ 1st\ timeslice\ only}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ h[X]\ *=\ 0.5;}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \}}

\end{DoxyCode}


{\ttfamily X} can be used only inside site loops. ~\newline
 Access operation {\ttfamily f\mbox{[}X\mbox{]}} can be applied only to field variables, and has the type of the field element (in the case above {\ttfamily mytype}).

{\ttfamily X} has methods\+:


\begin{DoxyItemize}
\item {\ttfamily Coordinate\+Vector X.\+coordinates()}\+: Coordinate\+Vector of the current site
\item {\ttfamily int X.\+coordinate(\+Direction)}\+: coordinate to direction
\item {\ttfamily Parity X.\+parity()}\+: parity of current site
\end{DoxyItemize}

The assignment {\ttfamily f\mbox{[}ALL\mbox{]} = 2 + g\mbox{[}X\mbox{]};} can also be done with {\ttfamily f = 2 + g}. The main difference is in sequencing\+: the first form goes through the lattice sites in one {\itshape site loop}, whereas the second stores the result of 2 + g to a temporary field variable which is copied to f (in this case std\+::moved). The site loop form is faster since it minimizes temporaries and memory accesses. ~\newline


Because {\ttfamily f\mbox{[}X\mbox{]}} is of type field element, the methods defined for the element type can be used. ~\newline
 {\ttfamily f\mbox{[}X\mbox{]}.dagger()} is ok, {\ttfamily f.\+dagger()} is not.

{\ttfamily f\mbox{[}X\mbox{]}} also serves as a visual identifier for a field variable access.

Reduction\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{C++}
\DoxyCodeLine{\ \ \ mytype\ d\ =\ 0;}
\DoxyCodeLine{\ \ \ onsites(ALL)\ d\ +=\ f[X]\ -\/\ g[X+e\_x];}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ hila::out0\ <<\ "{}The\ reduction\ is\ <<\ d\ <<\ std::endl;}

\end{DoxyCode}


Other features\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{C++}
\DoxyCodeLine{\ \ \ double\ a\ =\ 3,\ b\ =\ 5;}
\DoxyCodeLine{\ \ \ Field<double>\ f,\ g=0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ onsites(ALL)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ f[X]\ =\ (a\ +\ b);\ \ \ \ \ \ \ \ \ \ \ \ //\ ok,\ loop\ extern\ variables\ a,b\ do\ not\ change\ within\ the\ loop}
\DoxyCodeLine{\ \ \ \ \ \ \ b\ =\ f[X];\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ ERROR:\ cannot\ change\ a\ loop\ extern\ non-\/field\ variable\ (except\ reductions)}
\DoxyCodeLine{\ \ \ \ \ \ \ double\ c\ =\ sin(f[X]);\ \ \ \ \ \ //\ ok,\ variable\ c\ defined\ within\ the\ loop}
\DoxyCodeLine{\ \ \ \ \ \ \ f[X]\ =\ c\ +\ g;\ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ ERROR:\ using\ field\ variable\ g\ without\ [X]}
\DoxyCodeLine{\ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ CoordinateVector\ v\ =\ \{0,1,1,0\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ f\ =\ g.shift(v);\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ these\ two}
\DoxyCodeLine{\ \ \ f[ALL]\ =\ g[X\ +\ v];\ \ \ \ \ \ \ \ \ \ \ \ \ //\ are\ equivalent}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ f[EVEN]\ =\ g[X\ +\ v];\ \ \ \ \ \ \ \ \ \ \ \ //\ Cannot\ be\ done\ with\ g.shift()\ alone}

\end{DoxyCode}


Access field at a single point\+: {\ttfamily f\mbox{[}Coordinate\+Vector\mbox{]}}. This can be used only outside site loops.


\begin{DoxyCode}{0}
\DoxyCodeLine{C++}
\DoxyCodeLine{\ CoordinateVector\ v\ =\ \{2,3,4,5\};}
\DoxyCodeLine{\ auto\ value\ =\ f[v];\ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ "{}value"{}\ is\ broadcast\ to\ all\ nodes!}
\DoxyCodeLine{\ f[v]\ =\ 1;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ In\ assignment,\ values\ are\ not\ broadcast:\ the\ node\ which}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ owns\ site\ v\ must\ have\ correct\ rhs.}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md25}{}\doxysubsection{\texorpdfstring{Input library}{Input library}}\label{md_docs_2guide_2old__guide_autotoc_md25}
Class hila\+::input can be used to read parameters and other data for simulation programs. It matches key-\/value pairs from input files. As an example, if the file {\ttfamily parameters.\+dat} contains


\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ this\ is\ a\ comment}
\DoxyCodeLine{\#\ Run\ parameters\ for\ run\ XYZ}
\DoxyCodeLine{}
\DoxyCodeLine{lattice\ size\ \ 64,\ 64,\ 64,\ 128}
\DoxyCodeLine{beta\ \ \ \ \ \ \ \ \ \ 5.4}
\DoxyCodeLine{clover\ \ \ \ \ \ \ \ perturbative}
\DoxyCodeLine{}
\DoxyCodeLine{loops\ \ \ \ \ \ \ \ \ 25000}
\DoxyCodeLine{seed\ \ \ \ \ \ \ \ \ \ 3474212}
\DoxyCodeLine{}
\DoxyCodeLine{coefficients\ \ \ \ 0.5,\ 0.7,\ 0.85,\ 1.3,\ 1.6,\ 2}
\DoxyCodeLine{labels\ \ \ \ \ \ \ \ setA,\ setB,\ setC}

\end{DoxyCode}


it can be read (mostly) using the method {\ttfamily input\+::get(std\+::string key)}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ C++}
\DoxyCodeLine{\#include\ "{}hila.h"{}}
\DoxyCodeLine{}
\DoxyCodeLine{int\ main(int\ argc,\ char\ *\ argv[])\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ hila::initialize(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ open\ file\ after\ hila::initialize}
\DoxyCodeLine{\ \ \ \ //\ here\ to\ variable\ p}
\DoxyCodeLine{\ \ \ \ hila::input\ p("{}parameters.dat"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ CoordinateVector\ lsize\ =\ p.get("{}lattice\ size"{});}
\DoxyCodeLine{\ \ \ \ double\ beta\ \ \ \ \ \ \ \ \ \ \ \ =\ p.get("{}beta"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Calling\ get\_item()\ as\ below\ means\ that\ allowed\ values\ for\ }
\DoxyCodeLine{\ \ \ \ //\ "{}clover"{}\ are:\ \ "{}tree"{},\ "{}perturbative"{},\ or\ a\ float/double\ value.}
\DoxyCodeLine{\ \ \ \ //\ Return\ value\ is\ 0,\ 1,\ 2\ respectively.}
\DoxyCodeLine{\ \ \ \ int\ i\ =\ p.get\_item("{}clover"{},\{"{}tree"{},"{}perturbative"{},"{}\%f"{}\});}
\DoxyCodeLine{\ \ \ \ double\ clover;}
\DoxyCodeLine{\ \ \ \ if\ (i\ ==\ 0)\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ clover\ =\ 1;}
\DoxyCodeLine{\ \ \ \ else\ if\ (i\ ==\ 1)\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ clover\ =\ <perturbative\ expression>;}
\DoxyCodeLine{\ \ \ \ else\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ clover\ =\ p.get();\ \ //\ the\ number\ is\ read\ here\ without\ key\ argument}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ int\ loops\ \ \ \ \ \ \ =\ p.get("{}loops"{});}
\DoxyCodeLine{\ \ \ \ long\ rng\_seed\ \ \ =\ p.get("{}seed"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ reading\ a\ std::vector<>\ reads\ in\ comma-\/separated\ values}
\DoxyCodeLine{\ \ \ \ //\ this\ reads\ in\ a\ vector\ of\ 6\ doubles}
\DoxyCodeLine{\ \ \ \ std::vector<double>\ run\_coefficients\ =\ p.get("{}coefficients"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ and\ this\ a\ vector\ of\ 3\ strings}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ labels\ \ \ \ \ \ =\ p.get("{}labels"{});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ Close\ the\ file.\ File\ is\ also\ closed\ when\ p\ gets\ out\ of\ scope}
\DoxyCodeLine{\ \ \ \ p.close();\ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ //\ lattice\ setup\ is\ convenient\ to\ do\ after\ parameters\ have\ been\ read}
\DoxyCodeLine{\ \ \ \ lattice.setup(lsize);}

\end{DoxyCode}



\begin{DoxyItemize}
\item The method {\ttfamily input\+::get()} above deduces the type to be read in from the expected return value. The order is fixed, the items (lines) cannot be swapped (TODO\+: should this be allowed?). If an error occurs (wrong keys or values), program exits with an error message.
\item Because the order is fixed, the keys don\textquotesingle{}t really carry information for the program. However, they help to ensure that the values are as intended.
\item The method {\ttfamily input\+::get()} broadcasts the values to all nodes. They have to be called by all nodes simultaneously.
\item Method {\ttfamily input\+::get\+\_\+value()} has more options for synchronization and error returns. See documentation in {\ttfamily input.\+h}
\end{DoxyItemize}\hypertarget{md_docs_2guide_2old__guide_autotoc_md27}{}\doxysubsection{\texorpdfstring{Check input and layout}{Check input and layout}}\label{md_docs_2guide_2old__guide_autotoc_md27}
The input files and the lattice layout can be checked with the commands (after the application program has been built) 
\begin{DoxyCode}{0}
\DoxyCodeLine{bash}
\DoxyCodeLine{\ \ <hila-\/program-\/name>\ check}
\DoxyCodeLine{\ \ <hila-\/program-\/name>\ check=<number-\/of-\/nodes>\ \ \ \ \ \ \ \ \#\ without\ spaces}

\end{DoxyCode}
 This runs the program without initializing MPI, Cuda or other hardware features and exits at {\ttfamily lattice.\+setup()} before any large memory allocations are made. If the number-\/of-\/nodes argument is given, program reports how the node layout is done.

Example\+: if you built the {\ttfamily hila\+\_\+example} program above, in directory {\ttfamily hila/applications/hila\+\_\+example} the command {\ttfamily build/hila\+\_\+example check=32} checks the input file and the layout to 32 nodes.\hypertarget{md_docs_2guide_2old__guide_autotoc_md29}{}\doxysection{\texorpdfstring{Stale Instructions}{Stale Instructions}}\label{md_docs_2guide_2old__guide_autotoc_md29}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md30}{}\doxysubsection{\texorpdfstring{Generating documentation}{Generating documentation}}\label{md_docs_2guide_2old__guide_autotoc_md30}
Build the documentation (with the git hash as the version number) using 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ bash}
\DoxyCodeLine{PROJECT\_NUMBER=\$(git\ rev-\/parse\ -\/-\/short\ HEAD)\ doxygen}

\end{DoxyCode}
\hypertarget{md_docs_2guide_2old__guide_autotoc_md32}{}\doxysubsection{\texorpdfstring{Compiling the preprocessing tool and using it on c++ code}{Compiling the preprocessing tool and using it on c++ code}}\label{md_docs_2guide_2old__guide_autotoc_md32}
In short, the framework can be used in these steps\+:


\begin{DoxyEnumerate}
\item Write c++ code using the syntax and datatypes laid out below
\item Use the hilapp excecutable to convert this code into .cpt code
\item Compile the new .cpt code into the final excecutable
\end{DoxyEnumerate}



You can then use it to compile an extended C++ file into standard C++ using 
\begin{DoxyCode}{0}
\DoxyCodeLine{\ bash}
\DoxyCodeLine{bin/hilapp\ path/to/program.cpp}

\end{DoxyCode}
 This will create a {\ttfamily cpt} file written in standard C++.

The {\ttfamily cpt} can be compiled with any c++ compiler, but must be linked against the headers and c++ files in the plumbing directory.

Check the example programs in the programs folder. You can use almost any standard C++ code, by there are a couple of new reserved names\+: the variable {\ttfamily X} and the function {\ttfamily onsites()}. In addition the framework defines a global {\ttfamily lattice} variable, which you should not overwrite.

In order to use the additional features for field type variables, you should inlude {\ttfamily plumbing/field.\+h} in you program. You can also include one or more of the files in the {\ttfamily datatypes} folder, which contains predefined datatypes that can be used to construct a field. 
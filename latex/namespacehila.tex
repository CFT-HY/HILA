\doxysection{hila Namespace Reference}
\hypertarget{namespacehila}{}\label{namespacehila}\index{hila@{hila}}


let us house the partitions-\/struct here  


\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structhila_1_1base__type__struct}{base\+\_\+type\+\_\+struct}}
\item 
struct \mbox{\hyperlink{structhila_1_1complex__or__arithmetic__type__struct}{complex\+\_\+or\+\_\+arithmetic\+\_\+type\+\_\+struct}}
\item 
struct \mbox{\hyperlink{structhila_1_1complex__x__scalar__s}{complex\+\_\+x\+\_\+scalar\+\_\+s}}
\item 
struct \mbox{\hyperlink{structhila_1_1contains__complex}{contains\+\_\+complex}}
\item 
struct \mbox{\hyperlink{structhila_1_1contains__type}{contains\+\_\+type}}
\item 
struct \mbox{\hyperlink{structhila_1_1inner__type__struct}{inner\+\_\+type\+\_\+struct}}
\item 
struct \mbox{\hyperlink{structhila_1_1is__arithmetic}{is\+\_\+arithmetic}}
\item 
struct \mbox{\hyperlink{structhila_1_1is__complex}{is\+\_\+complex}}
\begin{DoxyCompactList}\small\item\em Define hila\+::is\+\_\+complex$<$\+T$>$\+::value -\/template, using specialization. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhila_1_1is__complex__or__arithmetic}{is\+\_\+complex\+\_\+or\+\_\+arithmetic}}
\begin{DoxyCompactList}\small\item\em hila\+::is\+\_\+complex\+\_\+or\+\_\+arithmetic$<$\+T$>$\+::value \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhila_1_1is__field__class__type}{is\+\_\+field\+\_\+class\+\_\+type}}
\item 
struct \mbox{\hyperlink{structhila_1_1is__field__type}{is\+\_\+field\+\_\+type}}
\item 
struct \mbox{\hyperlink{structhila_1_1is__vectorizable__type}{is\+\_\+vectorizable\+\_\+type}}
\begin{DoxyCompactList}\small\item\em is\+\_\+vectorizable\+\_\+type$<$\+T$>$\+::value is always false if the target is not vectorizable \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classhila_1_1k__binning}{k\+\_\+binning}}
\item 
struct \mbox{\hyperlink{structhila_1_1ntype__op__s}{ntype\+\_\+op\+\_\+s}}
\item 
class \mbox{\hyperlink{classhila_1_1timer}{timer}}
\item 
struct \mbox{\hyperlink{structhila_1_1timer__value}{timer\+\_\+value}}
\begin{DoxyCompactList}\small\item\em This file defines timer class and other timing related utilities. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structhila_1_1vector__info}{vector\+\_\+info}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename A , typename B $>$ }\\using \mbox{\hyperlink{namespacehila_adf272b5e8b834ba16564fd7bfff5adef}{type\+\_\+plus}} = decltype(std\+::declval$<$ A $>$()+std\+::declval$<$ B $>$())
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespacehila_a81cf9e19b8543be54f6afc7d2bd17805}\label{namespacehila_a81cf9e19b8543be54f6afc7d2bd17805} 
enum class \mbox{\hyperlink{namespacehila_a81cf9e19b8543be54f6afc7d2bd17805}{bc}} 
\begin{DoxyCompactList}\small\item\em list of field boundary conditions -\/ used only if SPECIAL\+\_\+\+BOUNDARY\+\_\+\+CONDITIONS defined \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ \mbox{\hyperlink{structhila_1_1contains__complex}{hila\+::contains\+\_\+complex}}$<$ T $>$\+::value, int $>$  = 0$>$ }\\\mbox{\hyperlink{classComplex}{Complex}}$<$ hila\+::scalar\+\_\+type$<$ T $>$ $>$ \mbox{\hyperlink{namespacehila_a6d0fc8cf25aca41ceac7aae4e5636064}{get\+\_\+complex\+\_\+in\+\_\+var}} (const T \&var, int i)
\item 
void \mbox{\hyperlink{namespacehila_a2a51f6f0888abf848ad7c4503a84d4ee}{free\+\_\+device\+\_\+rng}} ()
\begin{DoxyCompactList}\small\item\em Def here gpu rng functions for non-\/gpu. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{namespacehila_a926a1a1b5ae779ab700819db5e2afb1f}{broadcast}} (T \&var, int rank=0)
\item 
\Hypertarget{namespacehila_a592f9e6fc8b7df76ec8f991a4c121687}\label{namespacehila_a592f9e6fc8b7df76ec8f991a4c121687} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries broadcast} (const T \&var, int rank=0)
\begin{DoxyCompactList}\small\item\em Version of broadcast with non-\/modifiable var. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a2faa2b0e57cce3361a43e1dcf3571cb3}\label{namespacehila_a2faa2b0e57cce3361a43e1dcf3571cb3} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries broadcast} (std\+::vector$<$ T $>$ \&list, int rank=0)
\begin{DoxyCompactList}\small\item\em Broadcast for std\+::vector. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a23935e08fd4cfb80d68e7ff56d26514b}\label{namespacehila_a23935e08fd4cfb80d68e7ff56d26514b} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries broadcast} (T \texorpdfstring{$\ast$}{*}var)
\begin{DoxyCompactList}\small\item\em Bare pointers cannot be broadcast. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a2ee66a03e7f0ee2116276c5c22dc6b82}\label{namespacehila_a2ee66a03e7f0ee2116276c5c22dc6b82} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries broadcast\+\_\+array} (T \texorpdfstring{$\ast$}{*}var, int n, int rank=0)
\begin{DoxyCompactList}\small\item\em Broadcast for arrays where size must be known and same for all nodes. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_ad5660587b2ed9f51403974459bd42bca}\label{namespacehila_ad5660587b2ed9f51403974459bd42bca} 
{\footnotesize template$<$typename T , typename U $>$ }\\void {\bfseries broadcast2} (T \&t, U \&u, int rank=0)
\begin{DoxyCompactList}\small\item\em and broadcast with two values \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a530c7847f59bcca23ca23161f58424d5}\label{namespacehila_a530c7847f59bcca23ca23161f58424d5} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries reduce\+\_\+node\+\_\+sum} (T \texorpdfstring{$\ast$}{*}value, int send\+\_\+count, bool allreduce=true)
\begin{DoxyCompactList}\small\item\em Reduce an array across nodes. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_ad63afa9b048e8ea105e17ed96661b69c}\label{namespacehila_ad63afa9b048e8ea105e17ed96661b69c} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries reduce\+\_\+node\+\_\+sum} (T \&var, bool allreduce=true)
\begin{DoxyCompactList}\small\item\em Reduce single variable across nodes. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a5029fd8270d13272ea28643b49f12af6}\label{namespacehila_a5029fd8270d13272ea28643b49f12af6} 
void {\bfseries set\+\_\+allreduce} (bool on=true)
\begin{DoxyCompactList}\small\item\em set allreduce on (default) or off on the next reduction \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehila_a88d54715010ef67cf2fbea84b00f76bb}{initialize}} (int argc, char \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}argv)
\begin{DoxyCompactList}\small\item\em Read in command line arguments. Initialise default stream and MPI communication. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_ac4c73fee5aec8618b5c933a67822de1e}\label{namespacehila_ac4c73fee5aec8618b5c933a67822de1e} 
void {\bfseries finishrun} ()
\begin{DoxyCompactList}\small\item\em Normal, controlled exit -\/ all nodes must call this. Prints timing information and information about communications. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehila_adf07345c02b82159a0e7d0ee91f0cf34}{terminate}} (int status)
\item 
\Hypertarget{namespacehila_a1b8f68d0ba76b90e065cb427c20bb1d5}\label{namespacehila_a1b8f68d0ba76b90e065cb427c20bb1d5} 
void {\bfseries error} (const char \texorpdfstring{$\ast$}{*}msg)
\begin{DoxyCompactList}\small\item\em Print message and force quit. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacehila_a342d541c70e0e4756dfdd9dbf4c2b9c5}{myrank}} ()
\begin{DoxyCompactList}\small\item\em rank of this node \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespacehila_a46617d8162267096e14c8b0046a15fa6}{number\+\_\+of\+\_\+nodes}} ()
\begin{DoxyCompactList}\small\item\em how many nodes there are \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a4d1231fee312acb58bf9805b92114aa9}\label{namespacehila_a4d1231fee312acb58bf9805b92114aa9} 
void {\bfseries synchronize} ()
\begin{DoxyCompactList}\small\item\em synchronize mpi \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a929c11bba2f9ff3de00b5b886ae7ed9c}\label{namespacehila_a929c11bba2f9ff3de00b5b886ae7ed9c} 
bool {\bfseries bc\+\_\+need\+\_\+communication} (\mbox{\hyperlink{namespacehila_a81cf9e19b8543be54f6afc7d2bd17805}{hila\+::bc}} \mbox{\hyperlink{namespacehila_a81cf9e19b8543be54f6afc7d2bd17805}{bc}})
\begin{DoxyCompactList}\small\item\em False if we have b.\+c. which does not require communication. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacehila_aac91b8ebf153265b88955796ebd12a5f}{initialize\+\_\+host\+\_\+rng}} (uint64\+\_\+t seed)
\item 
void \mbox{\hyperlink{namespacehila_a90e5e5f9365383ef279039371798f09b}{seed\+\_\+random}} (uint64\+\_\+t seed, bool device\+\_\+rng=true)
\item 
void \mbox{\hyperlink{namespacehila_a17c785c728099c66865b717aebe26cdc}{initialize\+\_\+device\+\_\+rng}} (uint64\+\_\+t seed)
\item 
\Hypertarget{namespacehila_a5a53f45a43c7851763604561203673b3}\label{namespacehila_a5a53f45a43c7851763604561203673b3} 
bool {\bfseries is\+\_\+device\+\_\+rng\+\_\+on} ()
\begin{DoxyCompactList}\small\item\em Check if the RNG on GPU is allocated and ready to use. Returns true on non-\/\+GPU archs. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{random}} ()
\item 
double \mbox{\hyperlink{namespacehila_a61c7a1986bda1135c33fd13d0274a353}{gaussrand}} ()
\item 
double \mbox{\hyperlink{namespacehila_accb26f4a0a9d307c964e16f77239a960}{gaussrand2}} (double \&out2)
\item 
void \mbox{\hyperlink{namespacehila_acdf775f23790c6c2694313db8643c873}{check\+\_\+that\+\_\+rng\+\_\+is\+\_\+initialized}} ()
\begin{DoxyCompactList}\small\item\em RNG initialization check -\/ emitted on loops. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value, int $>$  = 0$>$ }\\T \mbox{\hyperlink{namespacehila_a185aa8fbf7349f39877175789e74f709}{random}} (out\+\_\+only T \&val)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{namespacehila_a9992a0fa128b359eba5eaa845d0b4f2e}{random}} ()
\item 
{\footnotesize template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value, int $>$  = 0$>$ }\\T \mbox{\hyperlink{namespacehila_afb91808d38476e2a469dcdd4dbd12eb5}{gaussian\+\_\+random}} (out\+\_\+only T \&val, double w=1.\+0)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{namespacehila_a07449948332d0d99ed46c1fdd373464c}{gaussian\+\_\+random}} ()
\item 
\Hypertarget{namespacehila_a532dfa5f086c9d157a00bf7e3465b003}\label{namespacehila_a532dfa5f086c9d157a00bf7e3465b003} 
{\footnotesize template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ \mbox{\hyperlink{structhila_1_1is__arithmetic}{hila\+::is\+\_\+arithmetic}}$<$ T $>$\+::value, int $>$  = 0$>$ }\\std\+::string {\bfseries to\+\_\+string} (const T v, int prec=8, char separator=\textquotesingle{} \textquotesingle{})
\begin{DoxyCompactList}\small\item\em convert to string\+: separator does nothing, but for compatibility w. other to\+\_\+strings \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespacehila_aa72756504f7ee068ec0b90fedfd07bfc}{gettime}} ()
\item 
{\footnotesize template$<$typename T $>$ }\\hila\+::scalar\+\_\+type$<$ T $>$ \mbox{\hyperlink{namespacehila_a74749529ceb2982ea9d68b53214f809c}{get\+\_\+number\+\_\+in\+\_\+var}} (const T \&var, int i)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespacehila_a5332679ab5ee4d7c673c633eb5b0f8c2}\label{namespacehila_a5332679ab5ee4d7c673c633eb5b0f8c2} 
std\+::ostream {\bfseries out}
\begin{DoxyCompactList}\small\item\em this is our default output file stream \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a7d333681d94db8e9eac675f2a7b5e3e6}\label{namespacehila_a7d333681d94db8e9eac675f2a7b5e3e6} 
std\+::ostream {\bfseries out0}
\begin{DoxyCompactList}\small\item\em This writes output only from main process (node 0) \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a82f4528a917b77019a48210412749c48}\label{namespacehila_a82f4528a917b77019a48210412749c48} 
std\+::ofstream {\bfseries output\+\_\+file}
\begin{DoxyCompactList}\small\item\em this is just a hook to store output file, if it is in use \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_a1aa9c123a15978119a29c53f30f6fa09}\label{namespacehila_a1aa9c123a15978119a29c53f30f6fa09} 
\mbox{\hyperlink{classlogger__class}{logger\+\_\+class}} {\bfseries log}
\begin{DoxyCompactList}\small\item\em Now declare the logger. \end{DoxyCompactList}\item 
\Hypertarget{namespacehila_aaeebd4241029719ec9549d1c411877ef}\label{namespacehila_aaeebd4241029719ec9549d1c411877ef} 
std\+::vector$<$ \mbox{\hyperlink{classhila_1_1timer}{timer}} \texorpdfstring{$\ast$}{*} $>$ {\bfseries timer\+\_\+list} = \{\}
\begin{DoxyCompactList}\small\item\em Timer routines -\/ for high-\/resolution event timing. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
let us house the partitions-\/struct here 

define hila\+::direction\+\_\+name() and hila\+::prettyprint(\+Direction)

////////////////////////////////////////////////////////////////////////////// Function hila\+::to\+\_\+string

Convert to string for \"{}pretty\"{} printing

Parameter file input system Check \doxylink{input_8h_source}{input.\+h} for user instructions

hila\+::input -\/ Class for parsing runtime parameter files

Input files consist normally of \"{}key $<$value$>$\"{} -\/pairs.

Comment character \textquotesingle{}\#\textquotesingle{}\+: everything after \# is a comment to the end of the line.

The values are read in sequentially, thus, they must be in the file in the order they are read in.

Class provides user functions open(), close(), get(), get\+\_\+item(), get\+\_\+value(), quiet()

hila\+::input f(\"{}filename\"{}); -\/ initialization with filename opens the file for input \hypertarget{namespacehila_autotoc_md17}{}\doxysubsubsection{\texorpdfstring{hila\+::input f;}{hila::input f;}}\label{namespacehila_autotoc_md17}
open()\+: open file for reading \begin{DoxyVerb}  bool hila::input::open(std::string filename,
                         bool use_cmdline,
                         bool exit_on_error=true)
\end{DoxyVerb}
 If use\+\_\+cmdline == true (default), use command line -\/i -\/argument to get the input file name. Then the \"{}filename\"{} is the default name used if there is no command line filename.

If exit\+\_\+on\+\_\+error == true, quit the program on error. The return value is passed to all MPI nodes.

f.\+open(\"{}filename\"{}); bool success = f.\+open(\"{}filename\"{},false);

\DoxyHorRuler{0}


get(std\+::string key) -\/ read input values

\doxylink{classhila_1_1input_1_1returntype}{hila\+::input\+::returntype} hila\+::input\+::get(std\+::string key)

Use as var = f.\+get(\"{}key\"{});

reads in a key-\/value pair key \texorpdfstring{$<$}{<}value(s)\texorpdfstring{$>$}{>} from the input file f, and returns the value of type of variable var. The value is broadcast to all MPI nodes. The method infers the type of the returned variable from the type of the assignment.

Key is an alphanumeric string, which may contain words separated by whitespace.

Recognized types\+: Any arithmetic type (ints/floats), Complex$<$float$>$, Complex$<$double$>$, std\+::string, Coordinate\+Vector, Vector$<$n,\+T$>$, std\+::vector$<$\+T$>$ where T is one of the above types

If there is an error, an error message is printed and the program quits.

Examples\+: \begin{DoxyVerb}int i = f.get("number of cats");
\end{DoxyVerb}
 matches \"{} number of cats   5 \"{} from the file f, and returns 5 on variable i, which is broadcast to all nodes. \begin{DoxyVerb}CoordinateVector v;
v = f.get("lattice size");
\end{DoxyVerb}
 matches \"{}lattice  size  32, 32, 32, 32\"{} (if NDIM == 4).

Multiple items are separated by commas, whitespace is not significant. \begin{DoxyVerb}std::vector<double> dvec = f.get("vec");
\end{DoxyVerb}
 matches \"{}vec  3,4, 5.\+5, 7.\+8, 4\"{} and returns a vector of double values. The numbers are read until they are not followed by a comma. If comma is the last non-\/whitespace character on the line, reading continues to the next line. \begin{DoxyVerb}Complex<double> phase = f.get("complex phase");
\end{DoxyVerb}
 matches \"{}complex phase   (0.\+4, 0.\+5)\"{} complex values are given in pairs within ( , ) \begin{DoxyVerb}std::string s = f.get("key");
\end{DoxyVerb}
 matches \"{}key $<$string value$>$\"{} where string value is either a) sequence of non-\/whitespace chars, delimited by whitespace, eol, \textquotesingle{},\textquotesingle{} or \textquotesingle{}\#\textquotesingle{}. b) characters enclosed by quotes \"{}..\"{}. These have to pair within the same line. Quote marks are removed.

If there is no key label, the value is read without requiring any key\+: \begin{DoxyVerb} int i = f.get();    // read an int
\end{DoxyVerb}
 \DoxyHorRuler{0}


get\+\_\+item()\+: select one item from a \"{}menu\"{}\+: \begin{DoxyVerb}   int hila::input::get_item(std::string key,
                   std::vector<std::string> items,
                   bool broadcast = true);
\end{DoxyVerb}
 \"{}items\"{} contains the allowed entries. Return value is the index of the item found in input file.

If the value of the optional bool parameter broadcast is\+:
\begin{DoxyItemize}
\item true (default)\+: the result is broadcast to all nodes and the program exits if no matches found.
\item false\+: result is not broadcast, and if no match found returns -\/1.
\end{DoxyItemize}

Special item values\+: \"{}\%f\"{} -\/ matches a float or double value \"{}\%i\"{} -\/ matches an int or long \"{}\%s\"{} -\/ matches any string value

If one of these is matched, it has to be read again with corresponding get() or get\+\_\+value() -\/method.

Examples\+: \begin{DoxyVerb} i = f.get_item("colour", {"red","green","blue"});
\end{DoxyVerb}
 will return value 1 if f contains \"{}colour  green\"{}, and quits the program if none of the 3 alternatives are found. \begin{DoxyVerb} double clover;
 int i = f.get_item("c_sw", {"tree","perturbative","%f"} );
 if (i == 2)
      clover = f.get();
 else { ...
\end{DoxyVerb}
 If file contains\+: c\+\_\+sw perturbative -\/ get\+\_\+item() returns 1 c\+\_\+sw 1.\+343 -\/ get\+\_\+item() returns 2 and subsequent get() sets c\+\_\+sw = 1.\+343 c\+\_\+sw abcd -\/ error message and quit

NOTE\+: \"{}\%s\"{} matches anything. It should be the last item in the list. (The items are tested in order and first to match is returned.)

\DoxyHorRuler{0}


get\+\_\+value()\+: read input (alternative to get()) \begin{DoxyVerb}   template <typename T>
   bool hila::input::get_value(T & val,std::string key,
                               bool broadcast=true);
\end{DoxyVerb}
 Val can be any value used in get()-\/method above. If broadcast==false, the value is not broadcast to other nodes. The return value is false if the value could not be read successfully, true otherwise. This method does not exit on error (but an error message may be printed) Example\+: int i,j; bool success; success = get\+\_\+value(i, \"{}key\"{}, false); // only node 0 gets i success = get\+\_\+value(j,\"{}key2\"{}); // all nodes get j

NOTE\+: if broadcast == false the return value is correct only on node 0.

\DoxyHorRuler{0}


close()\+: hila\+::input\+::close() \begin{DoxyVerb}    f.close();
\end{DoxyVerb}
 closes the input f. Now \"{}f.\+open(\"{}file\"{})\"{} can be used again. File is also closed when variable \"{}f\"{} goes out of scope.

\DoxyHorRuler{0}


quiet()\+: hila\+::input\+::quiet(bool be\+\_\+silent=true) \begin{DoxyVerb}    f.quiet();      // don't print read items to hila::out
    f.quiet(false); // re-enable printing
\end{DoxyVerb}
 By default hila\+::input methods print everything read to \doxylink{namespacehila_a5332679ab5ee4d7c673c633eb5b0f8c2}{hila\+::out} for logging. f.\+quiet(); disables this.

\DoxyHorRuler{0}


NOTE\+: methods which broadcast to all nodes (default) must be called from all nodes synchronously. These include open(), get(), get\+\_\+value() with bcast=true, get\+\_\+item with bcast=true.

Thus; if (\doxylink{namespacehila_a342d541c70e0e4756dfdd9dbf4c2b9c5}{hila\+::myrank()} == 0) \{ double v = f.\+get(\"{}a value\"{}); ... \}

deadlocks (if there are more than 1 rank). Method f.\+get\+\_\+value(v,\"{}a value\"{},false); can be used in this context.

Random shuffling of rng seed for MPI nodes Do it in a manner makes it difficult to give the same seed by mistake and also avoids giving the same seed for 2 nodes For single MPI node seed remains unchanged

Time related routines (runtime -\/ timing -\/ timelimit) Check \doxylink{timing_8h_source}{timing.\+h} for details 

\doxysubsection{Typedef Documentation}
\Hypertarget{namespacehila_adf272b5e8b834ba16564fd7bfff5adef}\label{namespacehila_adf272b5e8b834ba16564fd7bfff5adef} 
\index{hila@{hila}!type\_plus@{type\_plus}}
\index{type\_plus@{type\_plus}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{type\_plus}{type\_plus}}
{\footnotesize\ttfamily template$<$typename A , typename B $>$ \\
using \mbox{\hyperlink{namespacehila_adf272b5e8b834ba16564fd7bfff5adef}{hila\+::type\+\_\+plus}} = typedef decltype(std\+::declval$<$A$>$() + std\+::declval$<$B$>$())}

Helper operations to make generic templates for arithmetic operators e.\+g. \doxylink{namespacehila_adf272b5e8b834ba16564fd7bfff5adef}{hila\+::type\+\_\+plus$<$\+A,\+B$>$} gives the type of the operator a + b, where a is of type A and b type B. 

Definition at line \mbox{\hyperlink{type__tools_8h_source_l00103}{103}} of file \mbox{\hyperlink{type__tools_8h_source}{type\+\_\+tools.\+h}}.



\doxysubsection{Function Documentation}
\Hypertarget{namespacehila_a926a1a1b5ae779ab700819db5e2afb1f}\label{namespacehila_a926a1a1b5ae779ab700819db5e2afb1f} 
\index{hila@{hila}!broadcast@{broadcast}}
\index{broadcast@{broadcast}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{broadcast()}{broadcast()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T hila\+::broadcast (\begin{DoxyParamCaption}\item[{T \&}]{var,  }\item[{int}]{rank = {\ttfamily 0} }\end{DoxyParamCaption})}

Broadcast the value of {\itshape var} to all nodes from node {\itshape rank} (default=0). Var must be trivial, i.\+e. plain data. Returns the broadcast value If var is modifiable, it is changed to the broadcast value 

Definition at line \mbox{\hyperlink{com__mpi_8h_source_l00137}{137}} of file \mbox{\hyperlink{com__mpi_8h_source}{com\+\_\+mpi.\+h}}.

\Hypertarget{namespacehila_acdf775f23790c6c2694313db8643c873}\label{namespacehila_acdf775f23790c6c2694313db8643c873} 
\index{hila@{hila}!check\_that\_rng\_is\_initialized@{check\_that\_rng\_is\_initialized}}
\index{check\_that\_rng\_is\_initialized@{check\_that\_rng\_is\_initialized}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{check\_that\_rng\_is\_initialized()}{check\_that\_rng\_is\_initialized()}}
{\footnotesize\ttfamily void hila\+::check\+\_\+that\+\_\+rng\+\_\+is\+\_\+initialized (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



RNG initialization check -\/ emitted on loops. 

do what the name says -\/ program quits with error message if RNG is not initialized and on GPU archs the device RNG is not initialized. 

Definition at line \mbox{\hyperlink{random_8cpp_source_l00212}{212}} of file \mbox{\hyperlink{random_8cpp_source}{random.\+cpp}}.

\Hypertarget{namespacehila_a2a51f6f0888abf848ad7c4503a84d4ee}\label{namespacehila_a2a51f6f0888abf848ad7c4503a84d4ee} 
\index{hila@{hila}!free\_device\_rng@{free\_device\_rng}}
\index{free\_device\_rng@{free\_device\_rng}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{free\_device\_rng()}{free\_device\_rng()}}
{\footnotesize\ttfamily void hila\+::free\+\_\+device\+\_\+rng (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Def here gpu rng functions for non-\/gpu. 

Free GPU RNG state, \doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random()} does not work inside onsites() after this (unless seeded again using \doxylink{namespacehila_a17c785c728099c66865b717aebe26cdc}{initialize\+\_\+device\+\_\+rng()}). Frees the memory RNG takes on the device. Does nothing on non-\/\+GPU archs. 

Definition at line \mbox{\hyperlink{hila__gpu_8cpp_source_l00104}{104}} of file \mbox{\hyperlink{hila__gpu_8cpp_source}{hila\+\_\+gpu.\+cpp}}.

\Hypertarget{namespacehila_a07449948332d0d99ed46c1fdd373464c}\label{namespacehila_a07449948332d0d99ed46c1fdd373464c} 
\index{hila@{hila}!gaussian\_random@{gaussian\_random}}
\index{gaussian\_random@{gaussian\_random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{gaussian\_random()}{gaussian\_random()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T hila\+::gaussian\+\_\+random (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Template function T \doxylink{namespacehila_a07449948332d0d99ed46c1fdd373464c}{hila\+::gaussian\+\_\+random$<$\+T$>$()}; generates gaussian random value of type T, with variance 1. Example\+: auto n = \doxylink{namespacehila_a07449948332d0d99ed46c1fdd373464c}{hila\+::gaussian\+\_\+random$<$\+Complex$<$double$>$$>$()}.abs(); calculates the norm of a gaussian random complex value.

Note\+: there is no width/variance parameter, because of danger of confusion with above hila\+::gaussian\+\_\+random(value) 

Definition at line \mbox{\hyperlink{random_8h_source_l00175}{175}} of file \mbox{\hyperlink{random_8h_source}{random.\+h}}.

\Hypertarget{namespacehila_afb91808d38476e2a469dcdd4dbd12eb5}\label{namespacehila_afb91808d38476e2a469dcdd4dbd12eb5} 
\index{hila@{hila}!gaussian\_random@{gaussian\_random}}
\index{gaussian\_random@{gaussian\_random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{gaussian\_random()}{gaussian\_random()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value, int $>$  = 0$>$ \\
T hila\+::gaussian\+\_\+random (\begin{DoxyParamCaption}\item[{out\+\_\+only T \&}]{val,  }\item[{double}]{w = {\ttfamily 1.0} }\end{DoxyParamCaption})}

Template function const T \& \doxylink{namespacehila_afb91808d38476e2a469dcdd4dbd12eb5}{hila\+::gaussian\+\_\+random}(T \& variable,double width=1) Sets the argument to a gaussian random value, and return a constant reference to it. Optional second argument width sets the variance=width\texorpdfstring{$^\wedge$}{\string^}2 (default=1)

Example\+: Complex$<$double$>$ c; auto n = sqr(hila\+::gaussian\+\_\+random(c)); sets the variable c to complex gaussian random value and stores its square in n.

For hila classes relies on the existence of method T\+::gaussian\+\_\+random().

Advantage over class function T\+::random() is that the argument can be of elementary arithmetic type. 

Definition at line \mbox{\hyperlink{random_8h_source_l00152}{152}} of file \mbox{\hyperlink{random_8h_source}{random.\+h}}.

\Hypertarget{namespacehila_a61c7a1986bda1135c33fd13d0274a353}\label{namespacehila_a61c7a1986bda1135c33fd13d0274a353} 
\index{hila@{hila}!gaussrand@{gaussrand}}
\index{gaussrand@{gaussrand}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{gaussrand()}{gaussrand()}}
{\footnotesize\ttfamily double hila\+::gaussrand (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\doxylink{namespacehila_a61c7a1986bda1135c33fd13d0274a353}{hila\+::gaussrand()} returns a Gaussian distributed random number with variance 1.\+0, i.\+e. the probability distribution is exp( -\/x\texorpdfstring{$\ast$}{*}x/2 ), so \texorpdfstring{$<$}{<} x\texorpdfstring{$^\wedge$}{\string^}2 \texorpdfstring{$>$}{>} = 1 If you want random numbers with variance sigma, multiply the result by sqrt(sigma)\+: sqrt(sigma) \texorpdfstring{$\ast$}{*} \doxylink{namespacehila_a61c7a1986bda1135c33fd13d0274a353}{gaussrand()}; 

Definition at line \mbox{\hyperlink{random_8cpp_source_l00183}{183}} of file \mbox{\hyperlink{random_8cpp_source}{random.\+cpp}}.

\Hypertarget{namespacehila_accb26f4a0a9d307c964e16f77239a960}\label{namespacehila_accb26f4a0a9d307c964e16f77239a960} 
\index{hila@{hila}!gaussrand2@{gaussrand2}}
\index{gaussrand2@{gaussrand2}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{gaussrand2()}{gaussrand2()}}
{\footnotesize\ttfamily double hila\+::gaussrand2 (\begin{DoxyParamCaption}\item[{double \&}]{out2 }\end{DoxyParamCaption})}

\doxylink{namespacehila_accb26f4a0a9d307c964e16f77239a960}{hila\+::gaussrand2} returns 2 Gaussian distributed random numbers with variance 1.\+0. Useful because Box-\/\+Muller algorithm computes 2 values at the same time. 

Definition at line \mbox{\hyperlink{random_8cpp_source_l00166}{166}} of file \mbox{\hyperlink{random_8cpp_source}{random.\+cpp}}.

\Hypertarget{namespacehila_a6d0fc8cf25aca41ceac7aae4e5636064}\label{namespacehila_a6d0fc8cf25aca41ceac7aae4e5636064} 
\index{hila@{hila}!get\_complex\_in\_var@{get\_complex\_in\_var}}
\index{get\_complex\_in\_var@{get\_complex\_in\_var}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{get\_complex\_in\_var()}{get\_complex\_in\_var()}}
{\footnotesize\ttfamily template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ \mbox{\hyperlink{structhila_1_1contains__complex}{hila\+::contains\+\_\+complex}}$<$ T $>$\+::value, int $>$  = 0$>$ \\
\mbox{\hyperlink{classComplex}{Complex}}$<$ hila\+::scalar\+\_\+type$<$ T $>$ $>$ hila\+::get\+\_\+complex\+\_\+in\+\_\+var (\begin{DoxyParamCaption}\item[{const T \&}]{var,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

as\+\_\+complex\+\_\+array(\+T var) casts the var to a pointer to complex$<$scalar\+\_\+type$<$\+T$>$$>$ assuming var contains complex type. This enables access of complex elements as as\+\_\+complex\+\_\+array(var)\mbox{[}i\mbox{]} comment out as hilapp gets confused at the moment get\+\_\+complex\+\_\+element(var,i) returns the i\+:th complex number embedded in variable v set\+\_\+complex\+\_\+element(var,i,value) sets the i\+:th element in var 

Definition at line \mbox{\hyperlink{cmplx_8h_source_l00427}{427}} of file \mbox{\hyperlink{cmplx_8h_source}{cmplx.\+h}}.

\Hypertarget{namespacehila_a74749529ceb2982ea9d68b53214f809c}\label{namespacehila_a74749529ceb2982ea9d68b53214f809c} 
\index{hila@{hila}!get\_number\_in\_var@{get\_number\_in\_var}}
\index{get\_number\_in\_var@{get\_number\_in\_var}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{get\_number\_in\_var()}{get\_number\_in\_var()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
hila\+::scalar\+\_\+type$<$ T $>$ hila\+::get\+\_\+number\+\_\+in\+\_\+var (\begin{DoxyParamCaption}\item[{const T \&}]{var,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Access variables as if arrays of scalar\+\_\+type numbers 

Definition at line \mbox{\hyperlink{type__tools_8h_source_l00118}{118}} of file \mbox{\hyperlink{type__tools_8h_source}{type\+\_\+tools.\+h}}.

\Hypertarget{namespacehila_aa72756504f7ee068ec0b90fedfd07bfc}\label{namespacehila_aa72756504f7ee068ec0b90fedfd07bfc} 
\index{hila@{hila}!gettime@{gettime}}
\index{gettime@{gettime}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{gettime()}{gettime()}}
{\footnotesize\ttfamily double hila\+::gettime (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Use clock\+\_\+gettime() to get the accurate time (alternative\+: use gettimeofday() or MPI\+\_\+\+Wtime()) gettime returns the time in secs since program start 

Definition at line \mbox{\hyperlink{timing_8cpp_source_l00144}{144}} of file \mbox{\hyperlink{timing_8cpp_source}{timing.\+cpp}}.

\Hypertarget{namespacehila_a88d54715010ef67cf2fbea84b00f76bb}\label{namespacehila_a88d54715010ef67cf2fbea84b00f76bb} 
\index{hila@{hila}!initialize@{initialize}}
\index{initialize@{initialize}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{initialize()}{initialize()}}
{\footnotesize\ttfamily void hila\+::initialize (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{argv }\end{DoxyParamCaption})}



Read in command line arguments. Initialise default stream and MPI communication. 


\begin{DoxyParams}{Parameters}
{\em argc} & Number of command line arguments \\
\hline
{\em argv} & List of command line arguments \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{initialize_8cpp_source_l00174}{174}} of file \mbox{\hyperlink{initialize_8cpp_source}{initialize.\+cpp}}.

\Hypertarget{namespacehila_a17c785c728099c66865b717aebe26cdc}\label{namespacehila_a17c785c728099c66865b717aebe26cdc} 
\index{hila@{hila}!initialize\_device\_rng@{initialize\_device\_rng}}
\index{initialize\_device\_rng@{initialize\_device\_rng}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{initialize\_device\_rng()}{initialize\_device\_rng()}}
{\footnotesize\ttfamily void hila\+::initialize\+\_\+device\+\_\+rng (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed }\end{DoxyParamCaption})}

Initialize device random number generator on GPUs, if on GPU platform. No effect on other archs. On MPI shuffles the seed for different MPI ranks. Called by \doxylink{namespacehila_a90e5e5f9365383ef279039371798f09b}{seed\+\_\+random()} unless its 2nd argument is hila\+::device\+\_\+rng\+\_\+off. This can reinitialize device RNG free\textquotesingle{}d by \doxylink{namespacehila_a2a51f6f0888abf848ad7c4503a84d4ee}{free\+\_\+device\+\_\+rng()}. 

Definition at line \mbox{\hyperlink{hila__gpu_8cpp_source_l00070}{70}} of file \mbox{\hyperlink{hila__gpu_8cpp_source}{hila\+\_\+gpu.\+cpp}}.

\Hypertarget{namespacehila_aac91b8ebf153265b88955796ebd12a5f}\label{namespacehila_aac91b8ebf153265b88955796ebd12a5f} 
\index{hila@{hila}!initialize\_host\_rng@{initialize\_host\_rng}}
\index{initialize\_host\_rng@{initialize\_host\_rng}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{initialize\_host\_rng()}{initialize\_host\_rng()}}
{\footnotesize\ttfamily void hila\+::initialize\+\_\+host\+\_\+rng (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed }\end{DoxyParamCaption})}

Initialize host (CPU) random number generator separately, done implicitly by \doxylink{namespacehila_a90e5e5f9365383ef279039371798f09b}{seed\+\_\+random()} Parameter random number seed. On MPI shuffles different seed values for all MPI ranks. 

Definition at line \mbox{\hyperlink{random_8cpp_source_l00059}{59}} of file \mbox{\hyperlink{random_8cpp_source}{random.\+cpp}}.

\Hypertarget{namespacehila_a342d541c70e0e4756dfdd9dbf4c2b9c5}\label{namespacehila_a342d541c70e0e4756dfdd9dbf4c2b9c5} 
\index{hila@{hila}!myrank@{myrank}}
\index{myrank@{myrank}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{myrank()}{myrank()}}
{\footnotesize\ttfamily int hila\+::myrank (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



rank of this node 

Return my node number -\/ take care to return the previous node number if mpi is being torn down (used in destructors) 

Definition at line \mbox{\hyperlink{com__mpi_8cpp_source_l00235}{235}} of file \mbox{\hyperlink{com__mpi_8cpp_source}{com\+\_\+mpi.\+cpp}}.

\Hypertarget{namespacehila_a46617d8162267096e14c8b0046a15fa6}\label{namespacehila_a46617d8162267096e14c8b0046a15fa6} 
\index{hila@{hila}!number\_of\_nodes@{number\_of\_nodes}}
\index{number\_of\_nodes@{number\_of\_nodes}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{number\_of\_nodes()}{number\_of\_nodes()}}
{\footnotesize\ttfamily int hila\+::number\+\_\+of\+\_\+nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



how many nodes there are 

Return number of nodes or \"{}pseudo-\/nodes\"{}. 

Definition at line \mbox{\hyperlink{com__mpi_8cpp_source_l00246}{246}} of file \mbox{\hyperlink{com__mpi_8cpp_source}{com\+\_\+mpi.\+cpp}}.

\Hypertarget{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}\label{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42} 
\index{hila@{hila}!random@{random}}
\index{random@{random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{random()}{random()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily double hila\+::random (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random()} returns a uniform double precision random number in interval \mbox{[}0,1). Can be called from outside or inside site loops (on GPU if the device rng is initialized) 

Definition at line \mbox{\hyperlink{hila__gpu_8cpp_source_l00118}{118}} of file \mbox{\hyperlink{hila__gpu_8cpp_source}{hila\+\_\+gpu.\+cpp}}.

\Hypertarget{namespacehila_a9992a0fa128b359eba5eaa845d0b4f2e}\label{namespacehila_a9992a0fa128b359eba5eaa845d0b4f2e} 
\index{hila@{hila}!random@{random}}
\index{random@{random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{random()}{random()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T hila\+::random (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Template function T \doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random$<$\+T$>$()}; without argument. This is used to generate random value for T without defined variable. Example\+: auto n = \doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random$<$\+Complex$<$double$>$$>$()}.abs(); calculates the norm of a random complex value.

\doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random$<$double$>$()} is functionally equivalent to \doxylink{namespacehila_a619e441d1ebadab1a5d1d3f08b88fb42}{hila\+::random()} 

Definition at line \mbox{\hyperlink{random_8h_source_l00128}{128}} of file \mbox{\hyperlink{random_8h_source}{random.\+h}}.

\Hypertarget{namespacehila_a185aa8fbf7349f39877175789e74f709}\label{namespacehila_a185aa8fbf7349f39877175789e74f709} 
\index{hila@{hila}!random@{random}}
\index{random@{random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{random()}{random()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+arithmetic$<$ T $>$\+::value, int $>$  = 0$>$ \\
T hila\+::random (\begin{DoxyParamCaption}\item[{out\+\_\+only T \&}]{val }\end{DoxyParamCaption})}

Template function const T \& hila\+::random(\+T \& var) Sets the argument to a random value, and return a constant reference to it. Example\+: Complex$<$double$>$ c; auto n = hila\+::random(c).abs(); sets the variable c to complex random value and calculates its absolute value. c.\+real() and c.\+imag() will be \textbackslash{}in \mbox{[}0,1)

For hila classes relies on the existence of method T\+::random() (i.\+e. var.\+random())

Typically sets the argument real numbers to interval \mbox{[}0,1), but not always\+: for example, if T is SU$<$\+N,\+T$>$ -\/matrix sets the argument to valid random SU$<$\+N,\+T$>$.

Advantage over class function T\+::random() is that the argument can be of elementary arithmetic type. 

Definition at line \mbox{\hyperlink{random_8h_source_l00106}{106}} of file \mbox{\hyperlink{random_8h_source}{random.\+h}}.

\Hypertarget{namespacehila_a90e5e5f9365383ef279039371798f09b}\label{namespacehila_a90e5e5f9365383ef279039371798f09b} 
\index{hila@{hila}!seed\_random@{seed\_random}}
\index{seed\_random@{seed\_random}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{seed\_random()}{seed\_random()}}
{\footnotesize\ttfamily void hila\+::seed\+\_\+random (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed,  }\item[{bool}]{device\+\_\+init = {\ttfamily true} }\end{DoxyParamCaption})}

Seed random generators with 64-\/bit unsigned value. On MPI shuffles the seed so that different MPI ranks are seeded with different values.

The optional 2nd argument indicates whether to initialize the RNG on GPU device\+: hila\+::device\+\_\+rng\+\_\+on (default) or hila\+::device\+\_\+rng\+\_\+off. This argument does nothing if not GPU platform. If hila\+::device\+\_\+rng\+\_\+off is used, onsites() -\/loops cannot contain random number calls (Runtime error will be flagged and program exits).

Seed random number generators Seed is shuffled so that different nodes get different rng seeds. If seed == 0, generate seed using the time() -\/function. 

Definition at line \mbox{\hyperlink{random_8cpp_source_l00078}{78}} of file \mbox{\hyperlink{random_8cpp_source}{random.\+cpp}}.

\Hypertarget{namespacehila_adf07345c02b82159a0e7d0ee91f0cf34}\label{namespacehila_adf07345c02b82159a0e7d0ee91f0cf34} 
\index{hila@{hila}!terminate@{terminate}}
\index{terminate@{terminate}!hila@{hila}}
\doxysubsubsection{\texorpdfstring{terminate()}{terminate()}}
{\footnotesize\ttfamily void hila\+::terminate (\begin{DoxyParamCaption}\item[{int}]{status }\end{DoxyParamCaption})}

Force quit for multinode processes -- kill all nodes No synchronisation done 

Definition at line \mbox{\hyperlink{initialize_8cpp_source_l00367}{367}} of file \mbox{\hyperlink{initialize_8cpp_source}{initialize.\+cpp}}.


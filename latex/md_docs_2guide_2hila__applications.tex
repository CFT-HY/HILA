\chapter{Creating your first HILA application}
\hypertarget{md_docs_2guide_2hila__applications}{}\label{md_docs_2guide_2hila__applications}\index{Creating your first HILA application@{Creating your first HILA application}}
This section goes over how to get started with HILA and creating your first HILA application

Like most c++ applications, HILA applications require two things, a makefile and application source code. Due to the functionality that HILA offers, the makefile and source code follow a well defined structure. Generally HILA applications are at their core c++ and the user is free to implement any methods and libraries they see fit. But to implement the functionality that the pre processor offers, a well defined default application structure is introduced\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{applications/}
\DoxyCodeLine{├──\ hila\_example}
\DoxyCodeLine{│\ \ \ ├──\ build}
\DoxyCodeLine{│\ \ \ │\ \ \ ├──\ foo.cpt}
\DoxyCodeLine{│\ \ \ │\ \ \ ├──\ foo.o}
\DoxyCodeLine{|\ \ \ |\ \ \ .}
\DoxyCodeLine{|\ \ \ |\ \ \ ├──\ hila\_simple\_example.cpt}
\DoxyCodeLine{|\ \ \ |\ \ \ ├──\ hila\_simple\_example.o}
\DoxyCodeLine{|\ \ \ |\ \ \ .}
\DoxyCodeLine{│\ \ \ │\ \ \ ├──\ bar.cpt}
\DoxyCodeLine{│\ \ \ │\ \ \ └──\ bar.o}
\DoxyCodeLine{│\ \ \ ├──\ Makefile}
\DoxyCodeLine{│\ \ \ ├──\ parameters}
\DoxyCodeLine{│\ \ \ └──\ src}
\DoxyCodeLine{│\ \ \ \ \ \ \ ├──\ hila\_example.cpp}
\DoxyCodeLine{│\ \ \ \ \ \ \ └──\ hila\_simple\_example.cpp}
\DoxyCodeLine{.}
\DoxyCodeLine{.}
\DoxyCodeLine{.}

\end{DoxyCode}


In the structure HILA offers a directly, aptly named {\ttfamily applications}, where one can create their respective application directories. In here we have created a application directory {\ttfamily hila\+\_\+example} which we will highlight in this section. Inside the {\ttfamily hila\+\_\+example} directory we have the following necessary parts, visible in the above directory tree.

The {\ttfamily build} directory is the location to which the {\ttfamily .o} object files are dumped into. The object files are compiled from the {\ttfamily .cpt} files — these will be discussed later in the documentation — created by the hila preprocessor. The resulting executable after compilation is also compiled into this directory.

The {\ttfamily Makefile} is self evidently the necessary makefile used by make to compile the hila application.

The {\ttfamily parameters} file is an optional file to define application parameters into. This is not necessary for the use of HILA applications, but is quite useful. This will be discussed later

Lastly the {\ttfamily src} directory is the directory where the user will define their HILA applications. In here we have two example HILA applications of which we will highlight {\ttfamily \doxylink{hila__simple__example_8cpp_source}{hila\+\_\+simple\+\_\+example.\+cpp}}.

This file structure is necessary for the use of the makefile which handles the linking of HILA libraries used by the user.\hypertarget{md_docs_2guide_2hila__applications_autotoc_md5}{}\doxysection{\texorpdfstring{Table of contents}{Table of contents}}\label{md_docs_2guide_2hila__applications_autotoc_md5}

\begin{DoxyEnumerate}
\item \doxysectlink{md_docs_2guide_2hila__applications_makefile-system}{Makefile system}{1}
\item \doxysectlink{md_docs_2guide_2hila__applications_simple-hila-application}{Simple HILA application}{1}
\item \doxysectlink{md_docs_2guide_2hila__applications_conclusion}{Conclusion}{1}
\end{DoxyEnumerate}\hypertarget{md_docs_2guide_2hila__applications_makefile-system}{}\doxysection{\texorpdfstring{Makefile system}{Makefile system}}\label{md_docs_2guide_2hila__applications_makefile-system}
Each application requires a makefile to link the necessary HILA libraries and to allow specification of the target backend. An application makefile should define any target files and include the main makefile defined for the HILA libraries. The main makefile handles the HILA library linking and inclusion of the target backend.

The following makefile handles the compilation of two seperate hila example applications {\ttfamily \doxylink{hila__example_8cpp_source}{hila\+\_\+example.\+cpp}} and {\ttfamily \doxylink{hila__simple__example_8cpp_source}{hila\+\_\+simple\+\_\+example.\+cpp}}\+:

TODO\+: Figure out syntax highlighs and wrapping for markdown 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#\ Give\ the\ location\ of\ the\ top\ level\ distribution\ directory\ wrt.\ this\ location.}
\DoxyCodeLine{\#\ Can\ be\ absolute\ or\ relative\ }
\DoxyCodeLine{HILA\_DIR\ :=\ ../..}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ A\ useful\ definition\ is\ to\ set\ the\ default\ target\ backend\ to\ be\ used\ for\ computing.\ }
\DoxyCodeLine{\#\ In\ our\ example\ we\ set\ the\ default\ target\ backend\ to\ vanilla,\ which\ is\ the\ pure\ }
\DoxyCodeLine{\#\ CPU\ MPI\ implementation.}
\DoxyCodeLine{\#\ This\ allows\ one\ to\ skip\ the\ need\ of\ defining\ ARCH\ in\ the\ make\ process\ }
\DoxyCodeLine{\#\ \`{}make\ ARCH=vanilla\ -\/>\ make`.}
\DoxyCodeLine{ifndef\ ARCH}
\DoxyCodeLine{ARCH\ :=\ vanilla}
\DoxyCodeLine{endif}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ We\ then\ include\ the\ default\ makefile\ for\ hila\ applications\ which\ handles\ all}
\DoxyCodeLine{\#\ the\ nitty\ gritty\ of\ defining\ paths\ for\ the\ target\ architecture\ and\ linking\ }
\DoxyCodeLine{\#\ all\ the\ necessary\ libraries.\ This\ make\ file\ also\ handles\ use\ of\ the\ hila\ preprocessor:}
\DoxyCodeLine{include\ \$(HILA\_DIR)/libraries/main.mk}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ One\ can\ also\ define\ options\ for\ the\ HILA\ preprocessor\ in\ this\ makefile\ by\ }
\DoxyCodeLine{\#\ appending\ to\ the\ environment\ variable\ HILAPP\_OPTS}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ In\ the\ example\ code\ with\ add\ the\ \`{}-\/check-\/init`\ flag,\ but\ for\ now\ we\ will\ }
\DoxyCodeLine{\#\ not\ explain\ what\ it's\ use\ is.\ We\ will\ discuss\ all\ the\ hila\ preprocessor\ }
\DoxyCodeLine{\#\ flags\ later\ in\ the\ documentation.}
\DoxyCodeLine{HILAPP\_OPTS\ +=\ -\/check-\/init}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ Additionally\ one\ can\ add\ HILA\ application\ options\ in\ the\ makefile.\ }
\DoxyCodeLine{\#\ For\ example\ we\ set\ the\ system\ dimensions\ by\ appending\ to\ the\ }
\DoxyCodeLine{\#\ \`{}APP\_OPTS`\ environment\ variable}
\DoxyCodeLine{APP\_OPTS\ +=\ -\/DNDIM=3}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ With\ multiple\ targets\ we\ want\ to\ use\ "{}make\ target"{},\ not\ "{}make\ build/target"{}.}
\DoxyCodeLine{\#\ This\ is\ needed\ to\ carry\ the\ dependencies\ to\ build-\/subdir}
\DoxyCodeLine{hila\_example:\ build/hila\_example\ ;\ @:}
\DoxyCodeLine{hila\_simple\_example:\ build/hila\_simple\_example\ ;\ @:}
\DoxyCodeLine{}
\DoxyCodeLine{\#\ Now\ the\ linking\ step\ for\ each\ target\ executable}
\DoxyCodeLine{build/hila\_example:\ Makefile\ build/hila\_example.o\ \$(HILA\_OBJECTS)\ \$(HEADERS)}
\DoxyCodeLine{\ \ \ \ \$(LD)\ -\/o\ \$@\ build/hila\_example.o\ \$(HILA\_OBJECTS)\ \$(LDFLAGS)\ \$(LDLIBS)}
\DoxyCodeLine{}
\DoxyCodeLine{build/hila\_simple\_example:\ Makefile\ build/hila\_simple\_example.o\ \$(HILA\_OBJECTS)\ \$(HEADERS)}
\DoxyCodeLine{\ \ \ \ \$(LD)\ -\/o\ \$@\ build/hila\_simple\_example.o\ \$(HILA\_OBJECTS)\ \$(LDFLAGS)\ \$(LDLIBS)}

\end{DoxyCode}
 TODO\+: Fix doxygen not understanding makefile syntax highlights and text wrapping

The only point of note is the definition for the respective object file locations with {\ttfamily build/hila\+\_\+simple\+\_\+example.\+o}. For an applications this needs to be formatted in the same way as above, otherwise linking of c++ libraries and HILA objects will not be done correctly. The general format would be\+: \begin{DoxyVerb}build/{own application srouce name}: Makefile build/{own application srouce name}.o $(HILA_OBJECTS) $(HEADERS)
    $(LD) -o $@ build/{own application srouce name}.o $(HILA_OBJECTS) $(LDFLAGS) $(LDLIBS)
\end{DoxyVerb}
 \hypertarget{md_docs_2guide_2hila__applications_autotoc_md6}{}\doxysubsection{\texorpdfstring{Target backends}{Target backends}}\label{md_docs_2guide_2hila__applications_autotoc_md6}
The target backends are defined in the folder HILA/libraries/target\+\_\+arch. There are two types of target backends. General ones defined for specific paralellization technologies\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ ARCH=   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ ARCH=   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
{\ttfamily vanilla}   &default CPU implementation with MPI    \\\cline{1-2}
{\ttfamily AVX2}   &AVX vectorization optimized program using \href{https://github.com/vectorclass}{\texttt{ {\itshape vectorclass}}}    \\\cline{1-2}
{\ttfamily openmp}   &Open\+MP parallelized program    \\\cline{1-2}
{\ttfamily cuda}   &Parallel \href{https://developer.nvidia.com/cuda-toolkit}{\texttt{ CUDA}} program    \\\cline{1-2}
{\ttfamily hip}   &Parallel \href{https://docs.amd.com/bundle/HIP-Programming-Guide-v5.3/page/Introduction_to_HIP_Programming_Guide.html}{\texttt{ HIP}}   \\\cline{1-2}
\end{longtabu}


And ones which are defined for specific HPC platforms\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ ARCH=   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ ARCH=   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
{\ttfamily lumi}   &CPU-\/\+MPI implementation for LUMI supercomputer    \\\cline{1-2}
{\ttfamily lumi-\/hip}   &GPU-\/\+MPI implementation for LUMI supercomputer using HIP    \\\cline{1-2}
{\ttfamily mahti}   &CPU-\/\+MPI implementation for MAHTI supercomputer    \\\cline{1-2}
{\ttfamily mahti-\/cuda}   &GPU-\/\+MPI implementation for MAHTI supercomputer using CUDA   \\\cline{1-2}
\end{longtabu}


The latter definitions are due to the module systems and non-\/standard paths defined by supercomputing platforms.\hypertarget{md_docs_2guide_2hila__applications_simple-hila-application}{}\doxysection{\texorpdfstring{Simple hila application}{Simple hila application}}\label{md_docs_2guide_2hila__applications_simple-hila-application}
Now that we have discussed the appropriate makefile we can move on to a simple HILA application.

We offer a simple HILA application {\ttfamily \doxylink{hila__simple__example_8cpp_source}{hila\+\_\+simple\+\_\+example.\+cpp}} which computes a random gaussian field (f), it\textquotesingle{}s derivative (g) and the average of the derivative field is given by\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}hila.h"{}}}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(NDIM\ ==\ 3,\ \textcolor{stringliteral}{"{}NDIM\ must\ be\ 3"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{int}\ argc,\ \textcolor{keywordtype}{char}\ *\ argv[])\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacehila_a88d54715010ef67cf2fbea84b00f76bb}{hila::initialize}}(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ set\ up\ 32\string^3\ lattice}}
\DoxyCodeLine{\ \ \ \ lattice.\mbox{\hyperlink{classlattice__struct_a12f6b6a0c725399c8aa00740274b34b0}{setup}}(\{32,32,32\});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Random\ numbers\ are\ used\ here}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacehila_a90e5e5f9365383ef279039371798f09b}{hila::seed\_random}}(32345);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classField}{Field<Complex<double>}}>\ f;}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classField}{Field<double>}}\ g\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ make\ f\ Gaussian\ random\ distributed}}
\DoxyCodeLine{\ \ \ \ onsites(ALL)\ f[X].gaussian\_random();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ calculate\ sum\ of\ 2nd\ derivatives\ of\ f\ in\ to\ g}}
\DoxyCodeLine{\ \ \ \ foralldir(d)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ g[ALL]\ +=\ abs(f[X+d]\ -\/\ 2*f[X]\ +\ f[X-\/d]);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ get\ average\ of\ g}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{double}\ average\ =\ 0;}
\DoxyCodeLine{\ \ \ \ onsites(ALL)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ average\ +=\ g[X];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ average\ =\ average/lattice.volume()}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacehila_a7d333681d94db8e9eac675f2a7b5e3e6}{hila::out0}}\ <<\ \textcolor{stringliteral}{"{}Average\ of\ g\ is\ "{}}\ <<\ average\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ make\ a\ clean\ exit}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacehila_ac4c73fee5aec8618b5c933a67822de1e}{hila::finishrun}}();\ \ \ \ }
\DoxyCodeLine{\}}

\end{DoxyCode}


Like all c++ applications, our program starts withing the main function. Before it, we need to include some necessary header files. At the beginning of the file we include the {\ttfamily \doxylink{hila_8h_source}{hila.\+h}} header file which contains all of the definitions for HILA libraries. This is necessary to gain access to HILA functionality. Additionally we use a static\+\_\+assert to test our defined application option {\ttfamily -\/DNDIM=3}. This is useful redundancy so that we do not compile our application incorrectly. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}hila.h"{}}}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(NDIM\ ==\ 3,\ \textcolor{stringliteral}{"{}NDIM\ must\ be\ 3"{}});}

\end{DoxyCode}


After this process we call a few initialization and setup functions with the following lines of code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacehila_a88d54715010ef67cf2fbea84b00f76bb}{hila::initialize}}(argc,argv);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ set\ up\ 32\string^3\ lattice}}
\DoxyCodeLine{lattice.\mbox{\hyperlink{classlattice__struct_a12f6b6a0c725399c8aa00740274b34b0}{setup}}(\{32,32,32\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Random\ numbers\ are\ used\ here}}
\DoxyCodeLine{\mbox{\hyperlink{namespacehila_a90e5e5f9365383ef279039371798f09b}{hila::seed\_random}}(32345);}

\end{DoxyCode}


The first command {\ttfamily hila\+::initialize(argc,argv)} handles the initialization of mpi and reading in command line arguments and parameter files. This is a vital part of all HILA applications, but it is not too important for the user to understand what happens within it.

Next we setup the lattice and it\textquotesingle{}s size with the command {\ttfamily lattice.\+setup(\{32,32,32\})}. The {\ttfamily lattice} object is defined globally within hila and contains all the information on how the lattice is split within MPI. As with initialization, this is also a vital part of any HILA application, but is designed in a way where the user need not worry about it. Note that due to NDIM option above passing for example {\ttfamily \{32,32\}} to {\ttfamily lattice.\+setup()} would result in a runtime error. TODO\+: CATCH THIS ERROR

Lastly for setup we initialize the random number generator with the command {\ttfamily hila\+::seed\+\_\+random(32345)}. This will initialise the random number generator with the seed 32345.

Next in the application we define two Fields with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classField}{Field<Complex<double>}}>\ f;}
\DoxyCodeLine{\mbox{\hyperlink{classField}{Field<double>}}\ g\ =\ 0;}

\end{DoxyCode}


A \doxylink{classField}{Field} in HILA is the numerical object which we operate on and iterate over. The size and MPI layout of the Fields are inherited from the lattice structure which was initialized before hand with the {\ttfamily lattice.\+setup()} command. \doxylink{classField}{Field} is a c++ object which can be of many different data types and operations between them have been defined within HILA. This is implemented using standard c++ object oriented programming where we define the type within the brackets $<$\+T$>$. The available datatypes will be thoroughly documented later. For now we define one field of type {\ttfamily \doxylink{classComplex}{Complex}\texorpdfstring{$<$}{<}double\texorpdfstring{$>$}{>}} and {\ttfamily double}. The latter \doxylink{classField}{Field} g is initialized with the = constructor, where we set the \doxylink{classField}{Field} to be uniformly 0. The f \doxylink{classField}{Field} is initialized to null.

We then introduce our first onsites loop which set\textquotesingle{}s a complex gaussian random number for each point within the field\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{onsites(ALL)\ f[X].gaussian\_random();}

\end{DoxyCode}


In essence this is the most important functionality that HILA offers. Onsites loops allow the user to very simply loop over the whole field without having to think about indexing, memory alignment, communication or any of the complications that writing c++ and MPI brings about. Essentially these loops are glorified for loops. With the HILA pre processor the above onsites loop expands to the following c++ code\+:



{\bfseries{onsites expansion}}\begin{adjustwidth}{1em}{0em}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ make\ f\ Gaussian\ random\ distributed}}
\DoxyCodeLine{\ \ \ \ \ \textcolor{comment}{//-\/-\/\ \ onsites(ALL)\ f[X].gaussian\_random()}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \mbox{\hyperlink{namespacehila_acdf775f23790c6c2694313db8643c873}{hila::check\_that\_rng\_is\_initialized}}();}
\DoxyCodeLine{\ \ \ \ \ \ \mbox{\hyperlink{classField}{Field<Complex<double>}}>\ \&\ \_HILA\_field\_f\ =\ f;}
\DoxyCodeLine{\ \ \ \ \ \ \_HILA\_field\_f.\mbox{\hyperlink{classField_ab5b73a0d1ca55fb875e39558c721cc81}{check\_alloc}}();}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classlattice__struct}{lattice\_struct}}\ \&\ loop\_lattice\ =\ lattice;}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ loop\_begin\ =\ loop\_lattice.loop\_begin(Parity::all);}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ loop\_end\ \ \ =\ loop\_lattice.loop\_end(Parity::all);}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ \_HILA\_index\ =\ loop\_begin;\ \_HILA\_index\ <\ loop\_end;\ ++\_HILA\_index)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{classComplex}{Complex<double>}}\ \_HILA\_field\_f\_at\_X;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Initial\ value\ of\ variable\ \_HILA\_field\_f\_at\_X\ not\ needed}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \_HILA\_field\_f\_at\_X.\mbox{\hyperlink{classComplex_adc9a81d7f2b659e644ad94f49d656ad5}{gaussian\_random}}();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \_HILA\_field\_f.\mbox{\hyperlink{classField_a6e46f9db917092b26a09fe72dc625892}{set\_value\_at}}(\_HILA\_field\_f\_at\_X,\ \_HILA\_index);}
\DoxyCodeLine{\ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \mbox{\hyperlink{namespacehila_a5029fd8270d13272ea28643b49f12af6}{hila::set\_allreduce}}(\textcolor{keyword}{true});}
\DoxyCodeLine{\ \ \ \ \ \ \_HILA\_field\_f.\mbox{\hyperlink{classField_a23333e84caea23096552c81d4d14228f}{mark\_changed}}(Parity::all);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}

\end{DoxyCode}
 AHHH SCARY PUT IT AWAY!!! \end{adjustwidth}


As we can see the expansion is complicated and scary, one can imagine how complicated it get\textquotesingle{}s with different computing platforms. The X variable withing the onsites loop is a reserved variable within HILA applications. This variable is what defines the index of every point within the field. Appropriately the command {\ttfamily f\mbox{[}X\mbox{]}.gaussian\+\_\+random()} defines a gaussian random number for each point X within the field f. The ALL parameter within the onsites loop defines that we will iterate throughout the whole field. We will discuss variability of this parameter later in the documentation.

Next we compute $g(X) = |\nabla^2 f(X)| = \sum_{d \in \hat{e}} |f(X + d) - 2f(X) + f(X-d)| $, where $\hat{e} = \{e_x,e_y,e_z\}$ being the set of unit vectors that allow us to iterate over all directions. In HILA to iterate over all directions we use the foralldir pragma. The resulting HILA code is\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{foralldir(d)\ \{}
\DoxyCodeLine{\ \ \ \ g[ALL]\ +=\ abs(f[X+d]\ -\/\ 2*f[X]\ +\ f[X-\/d]);}
\DoxyCodeLine{\}}

\end{DoxyCode}


We use a sum reduction assignment operator withing the foralldir pragma to indicate the sum in the laplacian equation. With assignment operators we can use the ALL variable directly to index the field f, which is equivalent to writing\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{foralldir(d)\ \{}
\DoxyCodeLine{\ \ \ \ onsites(ALL)\ g[X]\ +=\ abs(f[X+d]\ -\/\ 2*f[X]\ +\ f[X-\/d]);}
\DoxyCodeLine{\}}

\end{DoxyCode}


We then compute the average of this previously computed norm of the Laplacian of the field f using a similar sum reduction with the assignment operator\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ average\ =\ 0;}
\DoxyCodeLine{onsites(ALL)\ \{}
\DoxyCodeLine{\ \ \ \ average\ +=\ g[X];}
\DoxyCodeLine{\}}

\end{DoxyCode}


We compute the average of each point with respect to the size of the system, which is give by {\ttfamily lattice.\+volume()}, since the lattice holds all the information of the systems structure. To output this value we use the default stream for text which limits the output only to the root node, so that we do not duplicate output from all mpi ranks. This default stream is held within the {\ttfamily \doxylink{namespacehila_a7d333681d94db8e9eac675f2a7b5e3e6}{hila\+::out0}} command contained in the {\ttfamily hila} namespace. It is of type {\ttfamily std\+::ostream} meaning that it is essentially an alias to {\ttfamily std\+::cout} of the zeroth node.


\begin{DoxyCode}{0}
\DoxyCodeLine{average\ =\ average/lattice.volume()}
\DoxyCodeLine{\mbox{\hyperlink{namespacehila_a7d333681d94db8e9eac675f2a7b5e3e6}{hila::out0}}\ <<\ \textcolor{stringliteral}{"{}Average\ of\ g\ is\ "{}}\ <<\ average\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}

\end{DoxyCode}


Lastly we wrap up the HILA application with the {\ttfamily \doxylink{namespacehila_ac4c73fee5aec8618b5c933a67822de1e}{hila\+::finishrun}} command which cleans up mpi and performs a safe exit with a memory cleanup step. Additionally it prints out useful timing information coupled with a timestamp. Like {\ttfamily \doxylink{namespacehila_a88d54715010ef67cf2fbea84b00f76bb}{hila\+::initialize}}, {\ttfamily lattice.\+setup} and {\ttfamily \doxylink{namespacehila_a90e5e5f9365383ef279039371798f09b}{hila\+::seed\+\_\+random}}, this is a necessary method to call in any HILA application, especially when running with MPI.\hypertarget{md_docs_2guide_2hila__applications_conclusion}{}\doxysection{\texorpdfstring{Conclusion}{Conclusion}}\label{md_docs_2guide_2hila__applications_conclusion}
This concludes the section on creating your first HILA application. We have gone through the basic structure of HILA applications, and how they are built and compiled. Additionally we have discussed basic functionality that HILA offers. With this foundational knowledge one can move on to reading the comprehensive guide on \doxysectlink{md_docs_2guide_2hila__functionality}{HILA functionality}{0} 
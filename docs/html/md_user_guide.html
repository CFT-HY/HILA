<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: User guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_user_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section is a user guide on building hila applications and a comprehensive description of the functionality it offers. For technical documentation each class, method, function etc. has been (work in progress) documented with standard docstring documentation which has been generated with doxygen.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
HILA Application</h1>
<p>Like most c++ applications, HILA applications require two thing, a makefile and application source code. Due to the functionality that HILA offers, the makefile and source code follow a well defined structure. Generally HILA applications are at their core c++ and the user is free to implement any methods and libraries they see fit. But to implement the functionality that the pre processor offers, a well defined skeleton is introduced.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Makefile system</h2>
<p>Each application requires a makefile to link the necessary HILA libraries and to allow specification of the target backend. An application makefile should define any target files and include the main makefile defined for the HILA libraries. The main makefile handles the HILA library linking and inclusion of the target backend.</p>
<p>Here is an example with comments: </p><div class="fragment"><div class="line">#NECESSARY</div>
<div class="line"># Give the location of the top level distribution directory wrt. this.</div>
<div class="line"># Can be absolute or relative</div>
<div class="line"># Allows the application folder to be defined anywhere in the machine</div>
<div class="line">HILA_DIR := ../..</div>
<div class="line"> </div>
<div class="line"># Set default goal</div>
<div class="line">.DEFAULT_GOAL := applications</div>
<div class="line"> </div>
<div class="line">#Set default architecture </div>
<div class="line">ifndef ARCH</div>
<div class="line">ARCH := vanilla</div>
<div class="line">endif</div>
<div class="line"> </div>
<div class="line"># Add an application specific header to the dependencies</div>
<div class="line">APP_HEADERS := application.h</div>
<div class="line"> </div>
<div class="line"># Read in the main makefile contents to link and build HILA libraries</div>
<div class="line">include $(TOP_DIR)/libraries/main.mk</div>
<div class="line"> </div>
<div class="line"># With multiple targets we want to use &quot;make target&quot;, not &quot;make build/target&quot;.</div>
<div class="line"># This is needed to build the dependencies in the build subdirectory</div>
<div class="line">application: build/application ; @:</div>
<div class="line"> </div>
<div class="line"># Now the linking step for each target executable</div>
<div class="line">build/application: Makefile build/application.o $(HILA_OBJECTS) $(HEADERS) </div>
<div class="line">    $(LD) -o $@ build/application.o $(HILA_OBJECTS) $(LDFLAGS) $(LDLIBS)</div>
</div><!-- fragment --><p>TODO: <b>Should the above makefile illustrate which aspects are necessary and which are not</b></p>
<p>The target backends are defined in the folder HILA/libraries/target_arch. There are two types of target backends. General ones defined for specific paralellization technologies:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ARCH=   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vanilla</code>   </td><td class="markdownTableBodyNone">default CPU implementation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>AVX2</code>   </td><td class="markdownTableBodyNone">AVX vectorization optimized program using <a href="https://github.com/vectorclass"><em>vectorclass</em></a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>openmp</code>   </td><td class="markdownTableBodyNone">OpenMP parallelized program    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>cuda</code>   </td><td class="markdownTableBodyNone">Parallel <a href="https://developer.nvidia.com/cuda-toolkit">CUDA</a> program    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>hip</code>   </td><td class="markdownTableBodyNone">Parallel <a href="https://docs.amd.com/bundle/HIP-Programming-Guide-v5.3/page/Introduction_to_HIP_Programming_Guide.html">HIP</a>   </td></tr>
</table>
<p>And ones which are defined for specific HPC platforms:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ARCH   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>lumi</code>   </td><td class="markdownTableBodyNone">CPU-MPI implementation for LUMI supercomputer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>lumi-hip</code>   </td><td class="markdownTableBodyNone">GPU-MPI implementation for LUMI supercomputer using HIP    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mahti</code>   </td><td class="markdownTableBodyNone">CPU-MPI implementation for MAHTI supercomputer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mahti-cuda</code>   </td><td class="markdownTableBodyNone">GPU-MPI implementation for MAHTI supercomputer using CUDA   </td></tr>
</table>
<p>The latter definitions are due to the module systems and non-standard paths defined by supercomputing platforms.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Simple hila application</h2>
<p>A simple HILA application which computes a random gaussian field (f), it's derivative (g) and the average of the derivative field is given by:</p>
<div class="fragment"><div class="line">#include &quot;hila.h&quot;</div>
<div class="line">static_assert(NDIM == 3, &quot;NDIM must be 3&quot;);</div>
<div class="line"> </div>
<div class="line">int main(int argc, char * argv[]) {</div>
<div class="line"> </div>
<div class="line">    hila::initialize(argc,argv);</div>
<div class="line"> </div>
<div class="line">    // set up 32^3 lattice</div>
<div class="line">    lattice.setup({32,32,32});</div>
<div class="line"> </div>
<div class="line">    // Random numbers are used here</div>
<div class="line">    hila::seed_random(32345);</div>
<div class="line"> </div>
<div class="line">    Field&lt;Complex&lt;double&gt;&gt; f;</div>
<div class="line">    Field&lt;double&gt; g = 0;</div>
<div class="line"> </div>
<div class="line">    // make f Gaussian random distributed</div>
<div class="line">    onsites(ALL) f[X].gaussian();</div>
<div class="line"> </div>
<div class="line">    // calculate sum of 2nd derivatives of f in to g</div>
<div class="line">    foralldir(d) {</div>
<div class="line">        g[ALL] += abs(f[X+d] - 2*f[X] + f[X-d]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // get average of g</div>
<div class="line">    double average = 0;</div>
<div class="line">    onsites(ALL) {</div>
<div class="line">        average += g[X];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    average = average/lattice.volume()</div>
<div class="line">    hila::out0 &lt;&lt; &quot;Average of g is &quot; &lt;&lt; average &lt;&lt; &#39;\n&#39;;</div>
<div class="line"> </div>
<div class="line">    // make a clean exit</div>
<div class="line">    hila::finishrun();    </div>
<div class="line">}</div>
</div><!-- fragment --><p>One can compile this code at <code>HILA/applications/hila_example/</code> with <code>make simple</code> and run it with <code>./build/simple</code>.</p>
<p>TODO: <b>CONTINUE FROM HERE</b></p>
<p><b>SHOULD THIS PART GO HERE</b> </p>
<h2><a class="anchor" id="autotoc_md6"></a>
HILA pre-processor tool</h2>
<p>In short, the framework can be used in these steps:</p>
<ol type="1">
<li>Write c++ code using the syntax and datatypes laid out below</li>
<li>Use the hilapp excecutable to convert this code into .cpt code</li>
<li>Compile the new .cpt code into the final excecutable</li>
</ol>
<p><img src="/docs/workflowV1.png" alt="Workflow illustration" class="inline"/></p>
<p>You can then use it to compile an extended C++ file into standard C++ using </p><div class="fragment"><div class="line">bin/hilapp path/to/program.cpp</div>
</div><!-- fragment --><p> This will create a <code>cpt</code> file written in standard C++.</p>
<p>The <code>cpt</code> can be compiled with any c++ compiler, but must be linked against the headers and c++ files in the plumbing directory.</p>
<p>Check the example programs in the programs folder. You can use almost any standard C++ code, by there are a couple of new reserved names: the variable <code>X</code> and the function <code>onsites()</code>. In addition the framework defines a global <code>lattice</code> variable, which you should not overwrite.</p>
<p>In order to use the additional features for field type variables, you should inlude <code><a class="el" href="field_8h.html">plumbing/field.h</a></code> in you program. You can also include one or more of the files in the <code>datatypes</code> folder, which contains predefined datatypes that can be used to construct a field.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
HILA Functionality</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Datatypes</h2>
<ul>
<li>NDIM: number of dimensions, values 2,3,4 (TODO: NDIM=1?). Typically set in application Makefile</li>
<li>Standard types: <code>int</code>, <code>int64_t</code>, <code>float</code>, <code>double</code> (<code>long double</code>?)</li>
<li><p class="startli">Hila provided basic types: <code><a class="el" href="classComplex.html">Complex</a>\&lt;S\&gt;</code>, <code>Vector\&lt;n,T\&gt;</code>, <code><a class="el" href="classMatrix.html" title="Generic Matrix class fwd definition.">Matrix</a>\&lt;n,m,T\&gt;</code>, <code>SquareMatrix\&lt;n,T\&gt;</code>, <code><a class="el" href="classArray.html" title="nxm Array type">Array</a>\&lt;n,m,T\&gt;</code></p>
<p class="startli">Here S is any standard type, and T includes S and <a class="el" href="classComplex.html">Complex</a>&lt;S&gt;. C++ or C standard complex types should not be used (not AVX vectorizable). See docs for functions/methods (TODO Doxygen docs)</p>
</li>
<li>Special types:<ul>
<li><code>Parity</code>: enum with values EVEN, ODD, ALL; refers to parity of the site. Parity of site (x,y,z,t) is even if <code>(x+y+z+t)</code> is even, odd otherwise.</li>
<li><code>Direction</code>: conceptually unit vector with values <code>±e_x, ±e_y, ±e_z, ±e_t</code> (if NDIM==4). Implemented as an enum class. Can be used to index arrays of size NDIM.</li>
<li><p class="startli"><code>CoordinateVector</code>: derived from Vector&lt;NDIM,int&gt;.</p>
<p class="startli">Direction variable acts as an unit vector in vector algebra: (assume below NDIM=4)</p>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">CoordinateVector v;</div>
<div class="line">Direction d = e_x;</div>
<div class="line">v = d;             // v = [1,0,0,0]</div>
<div class="line">v += e_y - 3*d;    // v = [-2,1,0,0]</div>
<div class="line">v = {0,1,-1,0};    // v = [0,1,-1,0] equivalent v = e_y - e_z;</div>
<div class="line">hila::out0 &lt;&lt; v.dot({1,2,3,4});  // dot product of 2 vectors, prints -1</div>
<div class="line">int j = d;         // ok</div>
<div class="line">d = j;             // ERROR: cannot assign int to Direction</div>
<div class="line">++d;               // e_x -&gt; e_y</div>
<div class="line">is_up_dir(d);      // true if d is along positive x,y,z,t -dir.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Field access and traversal</h2>
<p>The principal traversal of the lattice is with <em>site loops</em> <code>onsites(Parity)</code>, and a special location identifier <code>X</code> (effectively a new keyword). <br  />
</p>
<div class="fragment"><div class="line">using mytype = Matrix&lt;3,3,Complex&lt;double&gt;&gt;;   // use type alias</div>
<div class="line">Field&lt;mytype&gt; f,g,h;</div>
<div class="line">. . .</div>
<div class="line"> </div>
<div class="line">onsites(ALL) f[X] = 2 + g[X];          // 2 acts as 2*I for square matrices</div>
<div class="line">f[ALL] = 2 + g[X];                     // equivalent shorter form for simple 1-line assignments</div>
<div class="line">f = 2 + g;                             // this is also equivalent!</div>
<div class="line"> </div>
<div class="line">parity p = EVEN;</div>
<div class="line">Direction d = e_x;</div>
<div class="line"> </div>
<div class="line">onsites(p) {</div>
<div class="line">    auto t = g[X + d];                 // X +- Direction fetches from neighbour site</div>
<div class="line">    f[X] += t + t*t;                   // can define variables in the loop   </div>
<div class="line"> </div>
<div class="line">    h[X] = g[X + e_x - 2*e_y];         // non-nearest neighbour fetch (TODO:optimize!)</div>
<div class="line"> </div>
<div class="line">    if (X.coordinate(e_t) == 0) {      // Do this on 1st timeslice only</div>
<div class="line">         h[X] *= 0.5;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>X</code> can be used only inside site loops. <br  />
 Access operation <code>f[X]</code> can be applied only to field variables, and has the type of the field element (in the case above <code>mytype</code>).</p>
<p><code>X</code> has methods:</p>
<ul>
<li><code>CoordinateVector X.coordinates()</code>: CoordinateVector of the current site</li>
<li><code>int X.coordinate(Direction)</code>: coordinate to direction</li>
<li><code>Parity X.parity()</code>: parity of current site</li>
</ul>
<p>The assignment <code>f[ALL] = 2 + g[X];</code> can also be done with <code>f = 2 + g</code>. The main difference is in sequencing: the first form goes through the lattice sites in one <em>site loop</em>, whereas the second stores the result of 2 + g to a temporary field variable which is copied to f (in this case std::moved). The site loop form is faster since it minimizes temporaries and memory accesses. <br  />
</p>
<p>Because <code>f[X]</code> is of type field element, the methods defined for the element type can be used. <br  />
 <code>f[X].dagger()</code> is ok, <code>f.dagger()</code> is not.</p>
<p><code>f[X]</code> also serves as a visual identifier for a field variable access.</p>
<p><a class="el" href="classReduction.html">Reduction</a>:</p>
<div class="fragment"><div class="line">mytype d = 0;</div>
<div class="line">onsites(ALL) d += f[X] - g[X+e_x];</div>
<div class="line"> </div>
<div class="line">hila::out0 &lt;&lt; &quot;The reduction is &lt;&lt; d &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Other features:</p>
<div class="fragment"><div class="line">double a = 3, b = 5;</div>
<div class="line">Field&lt;double&gt; f, g=0;</div>
<div class="line"> </div>
<div class="line">onsites(ALL) {</div>
<div class="line">    f[X] = (a + b);            // ok, loop extern variables a,b do not change within the loop</div>
<div class="line">    b = f[X];                  // ERROR: cannot change a loop extern non-field variable (except reductions)</div>
<div class="line">    double c = sin(f[X]);      // ok, variable c defined within the loop</div>
<div class="line">    f[X] = c + g;              // ERROR: using field variable g without [X]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CoordinateVector v = {0,1,1,0};</div>
<div class="line"> </div>
<div class="line">f = g.shift(v);                // these two</div>
<div class="line">f[ALL] = g[X + v];             // are equivalent</div>
<div class="line"> </div>
<div class="line">f[EVEN] = g[X + v];            // Cannot be done with g.shift() alone</div>
</div><!-- fragment --><p>Access field at a single point: <code>f[CoordinateVector]</code>. This can be used only outside site loops.</p>
<div class="fragment"><div class="line">CoordinateVector v = {2,3,4,5};</div>
<div class="line">auto value = f[v];              // &quot;value&quot; is broadcast to all nodes!</div>
<div class="line">f[v] = 1;                       // In assignment, values are not broadcast: the node which</div>
<div class="line">                                // owns site v must have correct rhs.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Input library</h2>
<p>Class hila::input can be used to read parameters and other data for simulation programs. It matches key-value pairs from input files. As an example, if the file <code>parameters.dat</code> contains</p>
<div class="fragment"><div class="line"># this is a comment</div>
<div class="line"># Run parameters for run XYZ</div>
<div class="line"> </div>
<div class="line">lattice size  64, 64, 64, 128</div>
<div class="line">beta          5.4</div>
<div class="line">clover        perturbative</div>
<div class="line"> </div>
<div class="line">loops         25000</div>
<div class="line">seed          3474212</div>
<div class="line"> </div>
<div class="line">coefficients    0.5, 0.7, 0.85, 1.3, 1.6, 2</div>
<div class="line">labels        setA, setB, setC</div>
</div><!-- fragment --><p>it can be read (mostly) using the method <code>input::get(std::string key)</code>:</p>
<div class="fragment"><div class="line">#include &quot;hila.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char * argv[]) {</div>
<div class="line"> </div>
<div class="line">    hila::initialize(argc,argv);</div>
<div class="line"> </div>
<div class="line">    // open file after hila::initialize</div>
<div class="line">    // here to variable p</div>
<div class="line">    hila::input p(&quot;parameters.dat&quot;);</div>
<div class="line"> </div>
<div class="line">    CoordinateVector lsize = p.get(&quot;lattice size&quot;);</div>
<div class="line">    double beta            = p.get(&quot;beta&quot;);</div>
<div class="line"> </div>
<div class="line">    // Calling get_item() as below means that allowed values for </div>
<div class="line">    // &quot;clover&quot; are:  &quot;tree&quot;, &quot;perturbative&quot;, or a float/double value.</div>
<div class="line">    // Return value is 0, 1, 2 respectively.</div>
<div class="line">    int i = p.get_item(&quot;clover&quot;,{&quot;tree&quot;,&quot;perturbative&quot;,&quot;%f&quot;});</div>
<div class="line">    double clover;</div>
<div class="line">    if (i == 0) </div>
<div class="line">        clover = 1;</div>
<div class="line">    else if (i == 1) </div>
<div class="line">        clover = &lt;perturbative expression&gt;;</div>
<div class="line">    else </div>
<div class="line">        clover = p.get();  // the number is read here without key argument</div>
<div class="line"> </div>
<div class="line">    int loops       = p.get(&quot;loops&quot;);</div>
<div class="line">    long rng_seed   = p.get(&quot;seed&quot;);</div>
<div class="line"> </div>
<div class="line">    // reading a std::vector&lt;&gt; reads in comma-separated values</div>
<div class="line">    // this reads in a vector of 6 doubles</div>
<div class="line">    std::vector&lt;double&gt; run_coefficients = p.get(&quot;coefficients&quot;);</div>
<div class="line"> </div>
<div class="line">    // and this a vector of 3 strings</div>
<div class="line">    std::vector&lt;std::string&gt; labels      = p.get(&quot;labels&quot;);</div>
<div class="line"> </div>
<div class="line">    // Close the file. File is also closed when p gets out of scope</div>
<div class="line">    p.close();   </div>
<div class="line"> </div>
<div class="line">    // lattice setup is convenient to do after parameters have been read</div>
<div class="line">    lattice.setup(lsize);</div>
</div><!-- fragment --><ul>
<li>The method <code>input::get()</code> above deduces the type to be read in from the expected return value. The order is fixed, the items (lines) cannot be swapped (TODO: should this be allowed?). If an error occurs (wrong keys or values), program exits with an error message.</li>
<li>Because the order is fixed, the keys don't really carry information for the program. However, they help to ensure that the values are as intended.</li>
<li>The method <code>input::get()</code> broadcasts the values to all nodes. They have to be called by all nodes simultaneously.</li>
<li>Method <code>input::get_value()</code> has more options for synchronization and error returns. See documentation in <code><a class="el" href="input_8h_source.html">input.h</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Check input and layout</h2>
<p>The input files and the lattice layout can be checked with the commands (after the application program has been built) </p><div class="fragment"><div class="line">&lt;hila-program-name&gt; check</div>
<div class="line">&lt;hila-program-name&gt; check=&lt;number-of-nodes&gt;        # without spaces</div>
</div><!-- fragment --><p> This runs the program without initializing MPI, Cuda or other hardware features and exits at <code>lattice.setup()</code> before any large memory allocations are made. If the number-of-nodes argument is given, program reports how the node layout is done.</p>
<p>Example: if you built the <code>hila_example</code> program above, in directory <code>hila/applications/hila_example</code> the command <code>build/hila_example check=32</code> checks the input file and the layout to 32 nodes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

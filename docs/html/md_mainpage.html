<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Hila framework consists of</p>
<ol type="1">
<li>the hilapp and</li>
<li>a lattice simulation library.</li>
</ol>
<p>Transformer contains a C++ preprocessing tool and framework for programming lattice field theory simulations: the main method for getting measurements from non-perturbative quantum field theories. <br  />
</p>
<p>Lattice field theory simulations involve up to 4 dimensional grids whose points are updated continuously according to some Monte Carlo update algorithm. The update at each grid point depends on the data stored at neighboring lattice points, and the ideal update order depends on the parity of the lattice points. Efficient parallel implementations using MPI and GPU's can be quite complicated to implement, modify and debug. Some kind of simplification was clearly needed.</p>
<p>Transformer aims to make it easier for researchers to implement a broad class of these simulations by abstracting a lot of the technicalities involved, and by bringing the syntax from CUDA kernels and MPI calls to the essentials. The approach given here involves new datatypes and a preprocessing tool that converts c++ code with the new simplified syntax for loops and element accessors into working c++ code and gpu kernels.</p>
<p>Essentially, HilaPP extends C++ with statements of the following type: </p><div class="fragment"><div class="line">Field&lt;double&gt; f;</div>
<div class="line">f[ALL] = 1;</div>
<div class="line">f[EVEN] = f[X] + f[X+TUP];</div>
</div><!-- fragment --><p> The two latter statements are expanded into loops over all lattice sites and over EVEN sites, respectively. The ordering of sites in the loop is undefined.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
HilaPP</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Generating this documentation</h2>
<p>Build the documentation (with the git hash as the version number) using </p><div class="fragment"><div class="line">PROJECT_NUMBER=$(git rev-parse --short HEAD) doxygen</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Compiling the HilaPP and using it on c++ code</h2>
<p>In short, the framework can be used in these steps:</p>
<ol type="1">
<li>Write c++ code using the syntax and datatypes laid out below</li>
<li>Use the hilapp excecutable to convert this code into .cpt code</li>
<li>Compile the new .cpt code into the final excecutable</li>
</ol>
<p><a class="anchor" id="imgDef"></a><img src="workflowV1.png" alt="imgDef" title="Workflow illustration" class="inline"/></p>
<p>To compile the hilapp, first create a build directory inside the main directory if it doesn't exist. Then, compile the hilapp by typing <code>make</code> in the main folder. This will create an executable called <code>hilapp</code> in the build folder.</p>
<p>You can then use it to compile an extended C++ file into standard C++ using </p><div class="fragment"><div class="line">bin/hilapp path/to/program.cpp</div>
</div><!-- fragment --><p> This will create a <code>cpt</code> file written in standard C++.</p>
<p>The <code>cpt</code> can be compiled with any c++ compiler, but must be linked against the headers and c++ files in the plumbing directory.</p>
<p>Check the example programs in the programs folder. You can use almost any standard C++ code, by there are a couple of new reserved names: the variable <code>X</code> and the function <code>onsites()</code>. In addition the framework defines a global <code>lattice</code> variable, which you should not overwrite.</p>
<p>In order to use the additional features for field type variables, you should inlude <code><a class="el" href="field_8h_source.html">plumbing/field.h</a></code> in you program. You can also include one or more of the files in the <code>datatypes</code> folder, which contains predefined datatypes that can be used to construct a field.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Using the Makefile system</h2>
<p>Each of the example applications has a makefile for compiling the application with a given target backend. To compile it, run </p><div class="fragment"><div class="line">make TARGET=target program_name</div>
</div><!-- fragment --><p> The lower case target should be replaced by one of <code>vanilla</code>, <code>AVX</code> or <code>CUDA</code>. This will create a <code>build</code> directory and compile the application there.</p>
<p>An application makefile should define any target files and include the main makefile. Here is an example with comments: </p><div class="fragment"><div class="line"># Give the location of the top level distribution directory wrt. this.</div>
<div class="line"># Can be absolute or relative</div>
<div class="line">TOP_DIR := ../..</div>
<div class="line"> </div>
<div class="line"># Add an application specific header to the dependencies</div>
<div class="line">APP_HEADERS := application.h</div>
<div class="line"> </div>
<div class="line"># Read in the main makefile contents, incl. platforms</div>
<div class="line">include $(TOP_DIR)/libraries/main.mk</div>
<div class="line"> </div>
<div class="line"># With multiple targets we want to use &quot;make target&quot;, not &quot;make build/target&quot;.</div>
<div class="line"># This is needed to carry the dependencies to build-subdir</div>
<div class="line">application: build/application ; @:</div>
<div class="line"> </div>
<div class="line"># Now the linking step for each target executable</div>
<div class="line">build/application: Makefile build/application.o $(HILA_OBJECTS) $(HEADERS) </div>
<div class="line">    $(LD) -o $@ build/application.o $(HILA_OBJECTS) $(LDFLAGS) $(LDLIBS)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md5"></a>
Compiling on Puhti</h3>
<p>There is a separate makefile for compiling hilapp on Puhti. To use it, run </p><div class="fragment"><div class="line">module load gcc</div>
<div class="line">make -f Makefile_puhti</div>
</div><!-- fragment --><p>This will link against the llvm installation in the hila development project folder.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Syntax - What works</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Single line statements</h3>
<p>You can operate on fields using statements like </p><div class="fragment"><div class="line">my_field[ALL] = my_other_field[X] + my_third_field[X];</div>
</div><!-- fragment --><p> On the left-hand side of the statement you should specify either <code>[ALL]</code> lattice sites, <code>[EVEN]</code> sites or <code>[ODD]</code> sites. The statement will apply only to this collection of sites. On the right hand side, use <code>[X]</code> to refer to this collection of sites.</p>
<p>You can refer to neighbouring sites by adding a Direction (<code>e_x</code>, <code>-e_x</code>, <code>e_y</code>, <code>-e_y</code>, <code>e_z</code>, <code>-e_z</code>, <code>e_t</code>, <code>-e_t</code>, ...): </p><div class="fragment"><div class="line">my_field[EVEN] = my_field[X+e_y];</div>
</div><!-- fragment --><p>You can also operate on fields directly, </p><div class="fragment"><div class="line">my_field = my_field + 1;</div>
</div><!-- fragment --><p> This will operate on all sites and is equivalent to </p><div class="fragment"><div class="line">my_field[ALL] = my_field[X] + 1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
General loops</h3>
<p>Loops over all sites or a parity: </p><div class="fragment"><div class="line">forsites(ALL){}</div>
<div class="line">forsites(EVEN){}</div>
<div class="line">forsites(ODD){}</div>
</div><!-- fragment --><p> Inside the loop, refer to the sites using X: </p><div class="fragment"><div class="line">forsites(ALL){</div>
<div class="line">    my_field[X] = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As before, you can refer to neighbouring sites by adding a Direction: </p><div class="fragment"><div class="line">forsites(EVEN){</div>
<div class="line">    my_field[X] = my_field[X+e_y];</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
What doesn't work (as expected)</h2>
<p>Functions that implicitly depend on the site and return a number. For example </p><div class="fragment"><div class="line">forsites(EVEN){</div>
<div class="line">    matrix_field[X].gaussian();</div>
<div class="line">}</div>
</div><!-- fragment --><p> runs incorrectly with AVX. It does not actually run once for each site, but only once for each vector.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Extensions</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
HMC</h2>
<h3><a class="anchor" id="autotoc_md12"></a>
Gauge field</h3>
<p>The <a class="el" href="classgauge__field__base.html">gauge field</a> class is mainly a convenient wrapper containing a matrix field for each Direction. It allows us to refer to the gauge field as <code><a class="el" href="classgauge__field.html">gauge_field</a>&lt;SUN&gt; U</code> rather than <code>SUN U[NDIM]</code>, which is inconvenient to pass as a reference.</p>
<p>The <a class="el" href="classgauge__field__base.html">gauge fields</a> also contains a momentum field. Since fields are only allocated if necessary, this is not a large amount of data. <a class="el" href="classgauge__field.html">Fundamental gauge fields</a> can also store a copy of the gauge field for HMC.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Actions</h3>
<p><a class="el" href="classaction__base.html">Actions</a> represent terms in the full action of a quantum field theory and are used to set up the HMC simulation. Each <a class="el" href="classaction__base.html">action</a> implements at least</p>
<ol type="1">
<li><code>double action()</code>: returns the current value of the action</li>
<li><code>void force_step()</code>: calculates the derivative and updates canonical momenta</li>
<li><code>void draw_gaussian_fields()</code>: draws random values for any gaussian fields</li>
<li><code>void backup_fields()</code>: make a backup of gauge fields at the beginning of HMC</li>
<li><code>void restore_backup()</code>: restore the original field from the backup if the update is rejected</li>
</ol>
<p>For example, the <a class="el" href="classgauge__action.html">gauge action</a> represents the Wilson plaquette action </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_{gauge} = \sum_x \beta\left [ 1 - Re \sum_{\mu&gt;\nu} U_{x,\mu} U_{x+\mu,\nu} U^\dagger_{x+\nu, \mu} U^\dagger_{x,\nu} \right ] \]" src="form_0.png" width="274" height="40"/>
</p>
<p>The <a class="el" href="classfermion__action.html">fermion action</a> represents the pseudo fermion action </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_{fermion} = e^{-\sum_{x,y} \chi_x^\dagger \left(\frac{1}{D^\dagger D}\right)_{x,y} \chi_y}. \]" src="form_1.png" width="181" height="24"/>
</p>
<p> The Dirac operator can be any of the implemented <a class="el" href="classDirac__Wilson.html">Wilson Dirac</a> operator, the <a class="el" href="classDirac__Wilson__evenodd.html">even-odd preconditioned Wilson Dirac</a> operator, the <a class="el" href="classdirac__staggered.html">staggered Dirac</a> operator or the <a class="el" href="classdirac__staggered__evenodd.html">even-odd preconditioned staggered Dirac</a> operator. See operators below for more detail about how these and the matrix inversion are used.</p>
<p>At small mass it is often more efficient to split the fermion determinant </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z_{fermion} = \int d\chi e^{-S_{fermion}} = det\left( D^\dagger D \right) \]" src="form_2.png" width="220" height="29"/>
</p>
<p> to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ det\left( D^\dagger D \right) = det\left( (D + m)^\dagger (D + m) \right) det\left( \frac{ D^\dagger D }{(D + m)^\dagger (D + m)} \right) \]" src="form_3.png" width="340" height="33"/>
</p>
<p> To use this, you need two actions, <a class="el" href="classHasenbusch__action__1.html">Hasenbusch action 1</a> and <a class="el" href="classHasenbusch__action__2.html">Hasenbusch action 2</a>.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Integrators</h3>
<p>An <a class="el" href="classintegrator__base.html">integrator</a> updates the gauge fields and their canonical momenta keeping the action approximately constant. Two integrators are defined, the <a class="el" href="classleapfrog__integrator.html">leapfrog</a> and the <a class="el" href="classO2__integrator.html">O2</a> (aka Omelyan) integrators.</p>
<p><a class="el" href="classintegrator__base.html">Integrators</a> are constructed from an action term and a lower level integrator (or the momentum action on the lowest level). An integrator step updates the gauge field keeping the action approximately constant.</p>
<p><a class="el" href="classintegrator__base.html">Integrators</a> form a hierarchy, where lowest levels are run more often in a trajectory. The momentum action is also an integrator and forms the lowest level. Generally the force of the gauge action is fast to calculate and should be added second. The fermion action is the most expensive due to the inversion of the Dirac matrix and should be added on a high level.</p>
<p>The <a class="el" href="classleapfrog__integrator.html">leapfrog</a> integrator requires a single evaluation of the derivative of the action term and conserves the action to second order in the step size. The <a class="el" href="classO2__integrator.html">O2</a> integrator conserves the action to the third order in the, but requires two evaluations.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Full HMC</h3>
<p>The full process of setting up HMC is </p><div class="fragment"><div class="line">// First define a gauge field</div>
<div class="line">gauge_field&lt;SU&lt;N, double&gt;&gt; gauge;</div>
<div class="line"> </div>
<div class="line">// Let&#39;s just start from unity</div>
<div class="line">gauge.set_unity();</div>
<div class="line"> </div>
<div class="line">// Set up the action of the gauge and momentum actions</div>
<div class="line">gauge_action ga(gauge, beta);</div>
<div class="line">gauge_momentum_action ma(gauge);</div>
<div class="line"> </div>
<div class="line">// Set up the first level in the intergator hierarchy</div>
<div class="line">O2_integrator integrator_level_1(ga, ma);</div>
<div class="line"> </div>
<div class="line">// Define the Dirac operator</div>
<div class="line">dirac_staggered_evenodd D(mass, gauge);</div>
<div class="line"> </div>
<div class="line">// and the fermion action</div>
<div class="line">fermion_action fa(D, gauge);</div>
<div class="line"> </div>
<div class="line">// and finally the second level of the integrator</div>
<div class="line">O2_integrator integrator_level_2(fsum, integrator_level_1);</div>
<div class="line"> </div>
<div class="line">// Now we can run an HMC trajectory</div>
<div class="line">update_hmc(integrator_level_2, hmc_steps, traj_length);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Operators</h2>
<p>Operators are classes that define an <code>apply(<a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; input, <a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; output)</code> method. The method takes the a field and runs a transformation on it, returning the result in the output field.</p>
<p>The <a class="el" href="classDirac__Wilson.html">Wilson Dirac</a> and <a class="el" href="classdirac__staggered.html">staggered Dirac</a> operators are defined in libraries/dirac. They implement the two most common lattice Dirac operators. These files also have the even-odd preconditioned versions of these operators.</p>
<p>The Dirac operators also have a <code>dagger(<a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; input, <a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; output)</code> method, which implements the conjugate of the operator.</p>
<p>The <a class="el" href="classCG.html">conjugate gradient</a> operator calculates the inverse of the square of an operator applied to a vector </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ out = CG(D) in = \frac{1}{D^\dagger D} in. \]" src="form_4.png" width="146" height="26"/>
</p>
<p> In is defined in <a class="el" href="conjugate__gradient_8h_source.html">libraries/dirac/conjugate_gradient.h</a></p>
<p>Note that the <a class="el" href="classHasenbusch__operator.html">Hasenbusch preconditioned operator</a> in <a class="el" href="conjugate__gradient_8h_source.html">libraries/dirac/conjugate_gradient.h</a> is a utility class used in the Hasenbusch action.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Backends</h2>
<p>Backends are primarily implemented in three places. First, in HilaPP, loop generation and loop function handling code is in the files <code>hilapp/src/codegen_*.cpp</code>. The code generation functions are called in <a class="el" href="classGeneralVisitor.html#aa559b476c8579fbc38881735bfbf9cf0">backend_handle_loop_function</a> and <a class="el" href="classTopLevelVisitor.html#a1a26961c8e05d6325ee054f27f35e358">backend_generate_code</a>.</p>
<p>In order to define a new backend, you should edit the two functions above, implement the code generation function and add any new files to <code>hilapp/Makefile</code>.</p>
<p>Second, in the library in the folders <code>libraries/plumbing/backend_*</code>. These implement field storage in (usually in <code>field_storage_backend.h</code>), any other necessary top level definitions in <code>defs.h</code> and possible an extension of the lattice class in <code>lattice.h</code>. These are included in <code><a class="el" href="field__storage_8h_source.html">libraries/plumbing/field_storage.h</a></code>, <code><a class="el" href="defs_8h_source.html">libraries/plumbing/defs.h</a></code> and <code><a class="el" href="lattice_8h_source.html">libraries/plumbing/lattice.h</a></code> respectively.</p>
<p>A new backend should implement at least the field storage class. The new file needs to be included in <code><a class="el" href="field__storage_8h_source.html">libraries/plumbing/field_storage.h</a></code>.</p>
<p>Finally, <code>libraries/platforms</code> has a collection of makefiles, chosen by the <code>ARCH</code> flag in the standard Makefile. These include combinations of a specific system and a backend. New backend requires a new makefile that defines the necessary flags to produce and compile the correct code.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Testing</h1>
<p>In the <code>programs/test_cases</code> folder you can find a collection of simple test programs. To test whether the translations work on the cpu, type:</p>
<div class="fragment"><div class="line">./test.sh </div>
</div><!-- fragment --><p>This tests the transform, compilation and run process for the test_*.cpp files for dimensions from 1 to 4, and outputs the exit status of each step. If you're on a machine with GPU's, you can test the GPU transformations with:</p>
<div class="fragment"><div class="line">./test_GPU.sh</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md19"></a>
Goals</h1>
<ol type="1">
<li>Write tests for existing and new features<ul>
<li>Test also things that fail. The test basically defines how things should work.</li>
</ul>
</li>
<li>Extend to support:<ul>
<li>If (or where) statements in a loop</li>
</ul>
</li>
<li>Implement HIP backend (should be a simple replacement of CUDA syntax and functions)</li>
<li>Multiple lattices in one program</li>
<li>Expand and update documentation</li>
<li>Implement an OpenACC backend </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

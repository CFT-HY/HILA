<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: hila Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacehila.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">hila Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>let us house the partitions-struct here  
<a href="namespacehila.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1base__type__struct.html">base_type_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1complex__or__arithmetic__type__struct.html">complex_or_arithmetic_type_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1complex__x__scalar__s.html">complex_x_scalar_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1contains__complex.html">contains_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1contains__type.html">contains_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1inner__type__struct.html">inner_type_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define hila::is_complex&lt;T&gt;::value -template, using specialization.  <a href="structhila_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__complex__or__arithmetic.html">is_complex_or_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hila::is_complex_or_arithmetic&lt;T&gt;::value  <a href="structhila_1_1is__complex__or__arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__field__class__type.html">is_field_class_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__field__type.html">is_field_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1is__vectorizable__type.html">is_vectorizable_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_vectorizable_type&lt;T&gt;::value is always false if the target is not vectorizable  <a href="structhila_1_1is__vectorizable__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhila_1_1k__binning.html">k_binning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1ntype__op__s.html">ntype_op_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhila_1_1timer.html">timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1timer__value.html">timer_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines timer class and other timing related utilities.  <a href="structhila_1_1timer__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhila_1_1vector__info.html">vector_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adf272b5e8b834ba16564fd7bfff5adef"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:adf272b5e8b834ba16564fd7bfff5adef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#adf272b5e8b834ba16564fd7bfff5adef">type_plus</a> = decltype(std::declval&lt; A &gt;()+std::declval&lt; B &gt;())</td></tr>
<tr class="separator:adf272b5e8b834ba16564fd7bfff5adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a81cf9e19b8543be54f6afc7d2bd17805"><td class="memItemLeft" align="right" valign="top"><a id="a81cf9e19b8543be54f6afc7d2bd17805" name="a81cf9e19b8543be54f6afc7d2bd17805"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">bc</a> </td></tr>
<tr class="memdesc:a81cf9e19b8543be54f6afc7d2bd17805"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of field boundary conditions - used only if SPECIAL_BOUNDARY_CONDITIONS defined <br /></td></tr>
<tr class="separator:a81cf9e19b8543be54f6afc7d2bd17805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d0fc8cf25aca41ceac7aae4e5636064"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; <a class="el" href="structhila_1_1contains__complex.html">hila::contains_complex</a>&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6d0fc8cf25aca41ceac7aae4e5636064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classComplex.html">Complex</a>&lt; hila::scalar_type&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a6d0fc8cf25aca41ceac7aae4e5636064">get_complex_in_var</a> (const T &amp;var, int i)</td></tr>
<tr class="separator:a6d0fc8cf25aca41ceac7aae4e5636064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51f6f0888abf848ad7c4503a84d4ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a2a51f6f0888abf848ad7c4503a84d4ee">free_device_rng</a> ()</td></tr>
<tr class="memdesc:a2a51f6f0888abf848ad7c4503a84d4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Def here gpu rng functions for non-gpu.  <br /></td></tr>
<tr class="separator:a2a51f6f0888abf848ad7c4503a84d4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a1a1b5ae779ab700819db5e2afb1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a926a1a1b5ae779ab700819db5e2afb1f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a926a1a1b5ae779ab700819db5e2afb1f">broadcast</a> (T &amp;var, int rank=0)</td></tr>
<tr class="separator:a926a1a1b5ae779ab700819db5e2afb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592f9e6fc8b7df76ec8f991a4c121687"><td class="memTemplParams" colspan="2"><a id="a592f9e6fc8b7df76ec8f991a4c121687" name="a592f9e6fc8b7df76ec8f991a4c121687"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a592f9e6fc8b7df76ec8f991a4c121687"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast</b> (const T &amp;var, int rank=0)</td></tr>
<tr class="memdesc:a592f9e6fc8b7df76ec8f991a4c121687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of broadcast with non-modifiable var. <br /></td></tr>
<tr class="separator:a592f9e6fc8b7df76ec8f991a4c121687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa2b0e57cce3361a43e1dcf3571cb3"><td class="memTemplParams" colspan="2"><a id="a2faa2b0e57cce3361a43e1dcf3571cb3" name="a2faa2b0e57cce3361a43e1dcf3571cb3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2faa2b0e57cce3361a43e1dcf3571cb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast</b> (std::vector&lt; T &gt; &amp;list, int rank=0)</td></tr>
<tr class="memdesc:a2faa2b0e57cce3361a43e1dcf3571cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast for std::vector. <br /></td></tr>
<tr class="separator:a2faa2b0e57cce3361a43e1dcf3571cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23935e08fd4cfb80d68e7ff56d26514b"><td class="memTemplParams" colspan="2"><a id="a23935e08fd4cfb80d68e7ff56d26514b" name="a23935e08fd4cfb80d68e7ff56d26514b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23935e08fd4cfb80d68e7ff56d26514b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast</b> (T *var)</td></tr>
<tr class="memdesc:a23935e08fd4cfb80d68e7ff56d26514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bare pointers cannot be broadcast. <br /></td></tr>
<tr class="separator:a23935e08fd4cfb80d68e7ff56d26514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee66a03e7f0ee2116276c5c22dc6b82"><td class="memTemplParams" colspan="2"><a id="a2ee66a03e7f0ee2116276c5c22dc6b82" name="a2ee66a03e7f0ee2116276c5c22dc6b82"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ee66a03e7f0ee2116276c5c22dc6b82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast_array</b> (T *var, int n, int rank=0)</td></tr>
<tr class="memdesc:a2ee66a03e7f0ee2116276c5c22dc6b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast for arrays where size must be known and same for all nodes. <br /></td></tr>
<tr class="separator:a2ee66a03e7f0ee2116276c5c22dc6b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5660587b2ed9f51403974459bd42bca"><td class="memTemplParams" colspan="2"><a id="ad5660587b2ed9f51403974459bd42bca" name="ad5660587b2ed9f51403974459bd42bca"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad5660587b2ed9f51403974459bd42bca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast2</b> (T &amp;t, U &amp;u, int rank=0)</td></tr>
<tr class="memdesc:ad5660587b2ed9f51403974459bd42bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">and broadcast with two values <br /></td></tr>
<tr class="separator:ad5660587b2ed9f51403974459bd42bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530c7847f59bcca23ca23161f58424d5"><td class="memTemplParams" colspan="2"><a id="a530c7847f59bcca23ca23161f58424d5" name="a530c7847f59bcca23ca23161f58424d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a530c7847f59bcca23ca23161f58424d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_node_sum</b> (T *value, int send_count, bool allreduce=true)</td></tr>
<tr class="memdesc:a530c7847f59bcca23ca23161f58424d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an array across nodes. <br /></td></tr>
<tr class="separator:a530c7847f59bcca23ca23161f58424d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63afa9b048e8ea105e17ed96661b69c"><td class="memTemplParams" colspan="2"><a id="ad63afa9b048e8ea105e17ed96661b69c" name="ad63afa9b048e8ea105e17ed96661b69c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad63afa9b048e8ea105e17ed96661b69c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_node_sum</b> (T &amp;var, bool allreduce=true)</td></tr>
<tr class="memdesc:ad63afa9b048e8ea105e17ed96661b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce single variable across nodes. <br /></td></tr>
<tr class="separator:ad63afa9b048e8ea105e17ed96661b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5029fd8270d13272ea28643b49f12af6"><td class="memItemLeft" align="right" valign="top"><a id="a5029fd8270d13272ea28643b49f12af6" name="a5029fd8270d13272ea28643b49f12af6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_allreduce</b> (bool on=true)</td></tr>
<tr class="memdesc:a5029fd8270d13272ea28643b49f12af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set allreduce on (default) or off on the next reduction <br /></td></tr>
<tr class="separator:a5029fd8270d13272ea28643b49f12af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d54715010ef67cf2fbea84b00f76bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a88d54715010ef67cf2fbea84b00f76bb">initialize</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a88d54715010ef67cf2fbea84b00f76bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in command line arguments. Initialise default stream and MPI communication.  <br /></td></tr>
<tr class="separator:a88d54715010ef67cf2fbea84b00f76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c73fee5aec8618b5c933a67822de1e"><td class="memItemLeft" align="right" valign="top"><a id="ac4c73fee5aec8618b5c933a67822de1e" name="ac4c73fee5aec8618b5c933a67822de1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finishrun</b> ()</td></tr>
<tr class="memdesc:ac4c73fee5aec8618b5c933a67822de1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal, controlled exit - all nodes must call this. Prints timing information and information about communications. <br /></td></tr>
<tr class="separator:ac4c73fee5aec8618b5c933a67822de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf07345c02b82159a0e7d0ee91f0cf34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#adf07345c02b82159a0e7d0ee91f0cf34">terminate</a> (int status)</td></tr>
<tr class="separator:adf07345c02b82159a0e7d0ee91f0cf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f68d0ba76b90e065cb427c20bb1d5"><td class="memItemLeft" align="right" valign="top"><a id="a1b8f68d0ba76b90e065cb427c20bb1d5" name="a1b8f68d0ba76b90e065cb427c20bb1d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>error</b> (const char *msg)</td></tr>
<tr class="memdesc:a1b8f68d0ba76b90e065cb427c20bb1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print message and force quit. <br /></td></tr>
<tr class="separator:a1b8f68d0ba76b90e065cb427c20bb1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d541c70e0e4756dfdd9dbf4c2b9c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a342d541c70e0e4756dfdd9dbf4c2b9c5">myrank</a> ()</td></tr>
<tr class="memdesc:a342d541c70e0e4756dfdd9dbf4c2b9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">rank of this node  <br /></td></tr>
<tr class="separator:a342d541c70e0e4756dfdd9dbf4c2b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46617d8162267096e14c8b0046a15fa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a46617d8162267096e14c8b0046a15fa6">number_of_nodes</a> ()</td></tr>
<tr class="memdesc:a46617d8162267096e14c8b0046a15fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">how many nodes there are  <br /></td></tr>
<tr class="separator:a46617d8162267096e14c8b0046a15fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1231fee312acb58bf9805b92114aa9"><td class="memItemLeft" align="right" valign="top"><a id="a4d1231fee312acb58bf9805b92114aa9" name="a4d1231fee312acb58bf9805b92114aa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>synchronize</b> ()</td></tr>
<tr class="memdesc:a4d1231fee312acb58bf9805b92114aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">synchronize mpi <br /></td></tr>
<tr class="separator:a4d1231fee312acb58bf9805b92114aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c11bba2f9ff3de00b5b886ae7ed9c"><td class="memItemLeft" align="right" valign="top"><a id="a929c11bba2f9ff3de00b5b886ae7ed9c" name="a929c11bba2f9ff3de00b5b886ae7ed9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bc_need_communication</b> (<a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">hila::bc</a> <a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">bc</a>)</td></tr>
<tr class="memdesc:a929c11bba2f9ff3de00b5b886ae7ed9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">False if we have b.c. which does not require communication. <br /></td></tr>
<tr class="separator:a929c11bba2f9ff3de00b5b886ae7ed9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac91b8ebf153265b88955796ebd12a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#aac91b8ebf153265b88955796ebd12a5f">initialize_host_rng</a> (uint64_t seed)</td></tr>
<tr class="separator:aac91b8ebf153265b88955796ebd12a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e5e5f9365383ef279039371798f09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a90e5e5f9365383ef279039371798f09b">seed_random</a> (uint64_t seed, bool device_rng=true)</td></tr>
<tr class="separator:a90e5e5f9365383ef279039371798f09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c785c728099c66865b717aebe26cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a17c785c728099c66865b717aebe26cdc">initialize_device_rng</a> (uint64_t seed)</td></tr>
<tr class="separator:a17c785c728099c66865b717aebe26cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53f45a43c7851763604561203673b3"><td class="memItemLeft" align="right" valign="top"><a id="a5a53f45a43c7851763604561203673b3" name="a5a53f45a43c7851763604561203673b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_device_rng_on</b> ()</td></tr>
<tr class="memdesc:a5a53f45a43c7851763604561203673b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the RNG on GPU is allocated and ready to use. Returns true on non-GPU archs. <br /></td></tr>
<tr class="separator:a5a53f45a43c7851763604561203673b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e441d1ebadab1a5d1d3f08b88fb42"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">random</a> ()</td></tr>
<tr class="separator:a619e441d1ebadab1a5d1d3f08b88fb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c7a1986bda1135c33fd13d0274a353"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#a61c7a1986bda1135c33fd13d0274a353">gaussrand</a> ()</td></tr>
<tr class="separator:a61c7a1986bda1135c33fd13d0274a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb26f4a0a9d307c964e16f77239a960"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#accb26f4a0a9d307c964e16f77239a960">gaussrand2</a> (double &amp;out2)</td></tr>
<tr class="separator:accb26f4a0a9d307c964e16f77239a960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf775f23790c6c2694313db8643c873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#acdf775f23790c6c2694313db8643c873">check_that_rng_is_initialized</a> ()</td></tr>
<tr class="memdesc:acdf775f23790c6c2694313db8643c873"><td class="mdescLeft">&#160;</td><td class="mdescRight">RNG initialization check - emitted on loops.  <br /></td></tr>
<tr class="separator:acdf775f23790c6c2694313db8643c873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185aa8fbf7349f39877175789e74f709"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a185aa8fbf7349f39877175789e74f709"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a185aa8fbf7349f39877175789e74f709">random</a> (out_only T &amp;val)</td></tr>
<tr class="separator:a185aa8fbf7349f39877175789e74f709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9992a0fa128b359eba5eaa845d0b4f2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9992a0fa128b359eba5eaa845d0b4f2e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a9992a0fa128b359eba5eaa845d0b4f2e">random</a> ()</td></tr>
<tr class="separator:a9992a0fa128b359eba5eaa845d0b4f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb91808d38476e2a469dcdd4dbd12eb5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afb91808d38476e2a469dcdd4dbd12eb5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#afb91808d38476e2a469dcdd4dbd12eb5">gaussian_random</a> (out_only T &amp;val, double w=1.0)</td></tr>
<tr class="separator:afb91808d38476e2a469dcdd4dbd12eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07449948332d0d99ed46c1fdd373464c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07449948332d0d99ed46c1fdd373464c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a07449948332d0d99ed46c1fdd373464c">gaussian_random</a> ()</td></tr>
<tr class="separator:a07449948332d0d99ed46c1fdd373464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532dfa5f086c9d157a00bf7e3465b003"><td class="memTemplParams" colspan="2"><a id="a532dfa5f086c9d157a00bf7e3465b003" name="a532dfa5f086c9d157a00bf7e3465b003"></a>
template&lt;typename T , std::enable_if_t&lt; <a class="el" href="structhila_1_1is__arithmetic.html">hila::is_arithmetic</a>&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a532dfa5f086c9d157a00bf7e3465b003"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_string</b> (const T v, int prec=8, char separator=' ')</td></tr>
<tr class="memdesc:a532dfa5f086c9d157a00bf7e3465b003"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert to string: separator does nothing, but for compatibility w. other to_strings <br /></td></tr>
<tr class="separator:a532dfa5f086c9d157a00bf7e3465b003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72756504f7ee068ec0b90fedfd07bfc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehila.html#aa72756504f7ee068ec0b90fedfd07bfc">gettime</a> ()</td></tr>
<tr class="separator:aa72756504f7ee068ec0b90fedfd07bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74749529ceb2982ea9d68b53214f809c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74749529ceb2982ea9d68b53214f809c"><td class="memTemplItemLeft" align="right" valign="top">hila::scalar_type&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehila.html#a74749529ceb2982ea9d68b53214f809c">get_number_in_var</a> (const T &amp;var, int i)</td></tr>
<tr class="separator:a74749529ceb2982ea9d68b53214f809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5332679ab5ee4d7c673c633eb5b0f8c2"><td class="memItemLeft" align="right" valign="top"><a id="a5332679ab5ee4d7c673c633eb5b0f8c2" name="a5332679ab5ee4d7c673c633eb5b0f8c2"></a>
std::ostream&#160;</td><td class="memItemRight" valign="bottom"><b>out</b></td></tr>
<tr class="memdesc:a5332679ab5ee4d7c673c633eb5b0f8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is our default output file stream <br /></td></tr>
<tr class="separator:a5332679ab5ee4d7c673c633eb5b0f8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d333681d94db8e9eac675f2a7b5e3e6"><td class="memItemLeft" align="right" valign="top"><a id="a7d333681d94db8e9eac675f2a7b5e3e6" name="a7d333681d94db8e9eac675f2a7b5e3e6"></a>
std::ostream&#160;</td><td class="memItemRight" valign="bottom"><b>out0</b></td></tr>
<tr class="memdesc:a7d333681d94db8e9eac675f2a7b5e3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This writes output only from main process (node 0) <br /></td></tr>
<tr class="separator:a7d333681d94db8e9eac675f2a7b5e3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f4528a917b77019a48210412749c48"><td class="memItemLeft" align="right" valign="top"><a id="a82f4528a917b77019a48210412749c48" name="a82f4528a917b77019a48210412749c48"></a>
std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><b>output_file</b></td></tr>
<tr class="memdesc:a82f4528a917b77019a48210412749c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is just a hook to store output file, if it is in use <br /></td></tr>
<tr class="separator:a82f4528a917b77019a48210412749c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa9c123a15978119a29c53f30f6fa09"><td class="memItemLeft" align="right" valign="top"><a id="a1aa9c123a15978119a29c53f30f6fa09" name="a1aa9c123a15978119a29c53f30f6fa09"></a>
<a class="el" href="classlogger__class.html">logger_class</a>&#160;</td><td class="memItemRight" valign="bottom"><b>log</b></td></tr>
<tr class="memdesc:a1aa9c123a15978119a29c53f30f6fa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Now declare the logger. <br /></td></tr>
<tr class="separator:a1aa9c123a15978119a29c53f30f6fa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeebd4241029719ec9549d1c411877ef"><td class="memItemLeft" align="right" valign="top"><a id="aaeebd4241029719ec9549d1c411877ef" name="aaeebd4241029719ec9549d1c411877ef"></a>
std::vector&lt; <a class="el" href="classhila_1_1timer.html">timer</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>timer_list</b> = {}</td></tr>
<tr class="memdesc:aaeebd4241029719ec9549d1c411877ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer routines - for high-resolution event timing. <br /></td></tr>
<tr class="separator:aaeebd4241029719ec9549d1c411877ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>let us house the partitions-struct here </p>
<p>define hila::direction_name() and hila::prettyprint(Direction)</p>
<p>////////////////////////////////////////////////////////////////////////////// Function hila::to_string</p>
<p>Convert to string for "pretty" printing</p>
<p>Parameter file input system Check <a class="el" href="input_8h_source.html">input.h</a> for user instructions</p>
<p>hila::input - Class for parsing runtime parameter files</p>
<p>Input files consist normally of "key &lt;value&gt;" -pairs.</p>
<p>Comment character '#': everything after # is a comment to the end of the line.</p>
<p>The values are read in sequentially, thus, they must be in the file in the order they are read in.</p>
<p>Class provides user functions open(), close(), get(), get_item(), get_value(), quiet()</p>
<p>hila::input f("filename"); - initialization with filename opens the file for input </p>
<h2><a class="anchor" id="autotoc_md18"></a>
hila::input f;</h2>
<p>open(): open file for reading </p><pre class="fragment">  bool hila::input::open(std::string filename,
                         bool use_cmdline,
                         bool exit_on_error=true)
</pre><p> If use_cmdline == true (default), use command line -i -argument to get the input file name. Then the "filename" is the default name used if there is no command line filename.</p>
<p>If exit_on_error == true, quit the program on error. The return value is passed to all MPI nodes.</p>
<p>f.open("filename"); bool success = f.open("filename",false);</p>
<hr  />
<p>get(std::string key) - read input values</p>
<p><a class="el" href="classhila_1_1input_1_1returntype.html" title="returntyhpe is a special class for resolving get(&quot;label&quot;) return type">hila::input::returntype</a> hila::input::get(std::string key)</p>
<p>Use as var = f.get("key");</p>
<p>reads in a key-value pair key &lt;value(s)&gt; from the input file f, and returns the value of type of variable var. The value is broadcast to all MPI nodes. The method infers the type of the returned variable from the type of the assignment.</p>
<p>Key is an alphanumeric string, which may contain words separated by whitespace.</p>
<p>Recognized types: Any arithmetic type (ints/floats), Complex&lt;float&gt;, Complex&lt;double&gt;, std::string, CoordinateVector, Vector&lt;n,T&gt;, std::vector&lt;T&gt; where T is one of the above types</p>
<p>If there is an error, an error message is printed and the program quits.</p>
<p>Examples: </p><pre class="fragment">int i = f.get("number of cats");
</pre><p> matches " number of cats   5 " from the file f, and returns 5 on variable i, which is broadcast to all nodes. </p><pre class="fragment">CoordinateVector v;
v = f.get("lattice size");
</pre><p> matches "lattice  size  32, 32, 32, 32" (if NDIM == 4).</p>
<p>Multiple items are separated by commas, whitespace is not significant. </p><pre class="fragment">std::vector&lt;double&gt; dvec = f.get("vec");
</pre><p> matches "vec  3,4, 5.5, 7.8, 4" and returns a vector of double values. The numbers are read until they are not followed by a comma. If comma is the last non-whitespace character on the line, reading continues to the next line. </p><pre class="fragment">Complex&lt;double&gt; phase = f.get("complex phase");
</pre><p> matches "complex phase   (0.4, 0.5)" complex values are given in pairs within ( , ) </p><pre class="fragment">std::string s = f.get("key");
</pre><p> matches "key &lt;string value&gt;" where string value is either a) sequence of non-whitespace chars, delimited by whitespace, eol, ',' or '#'. b) characters enclosed by quotes "..". These have to pair within the same line. Quote marks are removed.</p>
<p>If there is no key label, the value is read without requiring any key: </p><pre class="fragment"> int i = f.get();    // read an int
</pre> <hr  />
<p>get_item(): select one item from a "menu": </p><pre class="fragment">   int hila::input::get_item(std::string key,
                   std::vector&lt;std::string&gt; items,
                   bool broadcast = true);
</pre><p> "items" contains the allowed entries. Return value is the index of the item found in input file.</p>
<p>If the value of the optional bool parameter broadcast is:</p><ul>
<li>true (default): the result is broadcast to all nodes and the program exits if no matches found.</li>
<li>false: result is not broadcast, and if no match found returns -1.</li>
</ul>
<p>Special item values: "%f" - matches a float or double value "%i" - matches an int or long "%s" - matches any string value</p>
<p>If one of these is matched, it has to be read again with corresponding get() or get_value() -method.</p>
<p>Examples: </p><pre class="fragment"> i = f.get_item("colour", {"red","green","blue"});
</pre><p> will return value 1 if f contains "colour  green", and quits the program if none of the 3 alternatives are found. </p><pre class="fragment"> double clover;
 int i = f.get_item("c_sw", {"tree","perturbative","%f"} );
 if (i == 2)
      clover = f.get();
 else { ...
</pre><p> If file contains: c_sw perturbative - get_item() returns 1 c_sw 1.343 - get_item() returns 2 and subsequent get() sets c_sw = 1.343 c_sw abcd - error message and quit</p>
<p>NOTE: "%s" matches anything. It should be the last item in the list. (The items are tested in order and first to match is returned.)</p>
<hr  />
<p>get_value(): read input (alternative to get()) </p><pre class="fragment">   template &lt;typename T&gt;
   bool hila::input::get_value(T &amp; val,std::string key,
                               bool broadcast=true);
</pre><p> Val can be any value used in get()-method above. If broadcast==false, the value is not broadcast to other nodes. The return value is false if the value could not be read successfully, true otherwise. This method does not exit on error (but an error message may be printed) Example: int i,j; bool success; success = get_value(i, "key", false); // only node 0 gets i success = get_value(j,"key2"); // all nodes get j</p>
<p>NOTE: if broadcast == false the return value is correct only on node 0.</p>
<hr  />
<p>close(): hila::input::close() </p><pre class="fragment">    f.close();
</pre><p> closes the input f. Now "f.open("file")" can be used again. File is also closed when variable "f" goes out of scope.</p>
<hr  />
<p>quiet(): hila::input::quiet(bool be_silent=true) </p><pre class="fragment">    f.quiet();      // don't print read items to hila::out
    f.quiet(false); // re-enable printing
</pre><p> By default hila::input methods print everything read to <a class="el" href="namespacehila.html#a5332679ab5ee4d7c673c633eb5b0f8c2" title="this is our default output file stream">hila::out</a> for logging. f.quiet(); disables this.</p>
<hr  />
<p>NOTE: methods which broadcast to all nodes (default) must be called from all nodes synchronously. These include open(), get(), get_value() with bcast=true, get_item with bcast=true.</p>
<p>Thus; if (<a class="el" href="namespacehila.html#a342d541c70e0e4756dfdd9dbf4c2b9c5" title="rank of this node">hila::myrank()</a> == 0) { double v = f.get("a value"); ... }</p>
<p>deadlocks (if there are more than 1 rank). Method f.get_value(v,"a value",false); can be used in this context.</p>
<p>Random shuffling of rng seed for MPI nodes Do it in a manner makes it difficult to give the same seed by mistake and also avoids giving the same seed for 2 nodes For single MPI node seed remains unchanged</p>
<p>Time related routines (runtime - timing - timelimit) Check <a class="el" href="timing_8h_source.html">timing.h</a> for details </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="adf272b5e8b834ba16564fd7bfff5adef" name="adf272b5e8b834ba16564fd7bfff5adef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf272b5e8b834ba16564fd7bfff5adef">&#9670;&#160;</a></span>type_plus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehila.html#adf272b5e8b834ba16564fd7bfff5adef">hila::type_plus</a> = typedef decltype(std::declval&lt;A&gt;() + std::declval&lt;B&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper operations to make generic templates for arithmetic operators e.g. <a class="el" href="namespacehila.html#adf272b5e8b834ba16564fd7bfff5adef">hila::type_plus&lt;A,B&gt;</a> gives the type of the operator a + b, where a is of type A and b type B. </p>

<p class="definition">Definition at line <a class="el" href="type__tools_8h_source.html#l00103">103</a> of file <a class="el" href="type__tools_8h_source.html">type_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a926a1a1b5ae779ab700819db5e2afb1f" name="a926a1a1b5ae779ab700819db5e2afb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a1a1b5ae779ab700819db5e2afb1f">&#9670;&#160;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hila::broadcast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Broadcast the value of <em>var</em> to all nodes from node <em>rank</em> (default=0). Var must be trivial, i.e. plain data. Returns the broadcast value If var is modifiable, it is changed to the broadcast value </p>

<p class="definition">Definition at line <a class="el" href="com__mpi_8h_source.html#l00137">137</a> of file <a class="el" href="com__mpi_8h_source.html">com_mpi.h</a>.</p>

</div>
</div>
<a id="acdf775f23790c6c2694313db8643c873" name="acdf775f23790c6c2694313db8643c873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf775f23790c6c2694313db8643c873">&#9670;&#160;</a></span>check_that_rng_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::check_that_rng_is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RNG initialization check - emitted on loops. </p>
<p>do what the name says - program quits with error message if RNG is not initialized and on GPU archs the device RNG is not initialized. </p>

<p class="definition">Definition at line <a class="el" href="random_8cpp_source.html#l00212">212</a> of file <a class="el" href="random_8cpp_source.html">random.cpp</a>.</p>

</div>
</div>
<a id="a2a51f6f0888abf848ad7c4503a84d4ee" name="a2a51f6f0888abf848ad7c4503a84d4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a51f6f0888abf848ad7c4503a84d4ee">&#9670;&#160;</a></span>free_device_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::free_device_rng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Def here gpu rng functions for non-gpu. </p>
<p>Free GPU RNG state, <a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random()</a> does not work inside onsites() after this (unless seeded again using <a class="el" href="namespacehila.html#a17c785c728099c66865b717aebe26cdc">initialize_device_rng()</a>). Frees the memory RNG takes on the device. Does nothing on non-GPU archs. </p>

<p class="definition">Definition at line <a class="el" href="hila__gpu_8cpp_source.html#l00104">104</a> of file <a class="el" href="hila__gpu_8cpp_source.html">hila_gpu.cpp</a>.</p>

</div>
</div>
<a id="a07449948332d0d99ed46c1fdd373464c" name="a07449948332d0d99ed46c1fdd373464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07449948332d0d99ed46c1fdd373464c">&#9670;&#160;</a></span>gaussian_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hila::gaussian_random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template function T <a class="el" href="namespacehila.html#a07449948332d0d99ed46c1fdd373464c">hila::gaussian_random&lt;T&gt;()</a>; generates gaussian random value of type T, with variance 1. Example: auto n = <a class="el" href="namespacehila.html#a07449948332d0d99ed46c1fdd373464c">hila::gaussian_random&lt;Complex&lt;double&gt;&gt;()</a>.abs(); calculates the norm of a gaussian random complex value.</p>
<p>Note: there is no width/variance parameter, because of danger of confusion with above hila::gaussian_random(value) </p>

<p class="definition">Definition at line <a class="el" href="random_8h_source.html#l00175">175</a> of file <a class="el" href="random_8h_source.html">random.h</a>.</p>

</div>
</div>
<a id="afb91808d38476e2a469dcdd4dbd12eb5" name="afb91808d38476e2a469dcdd4dbd12eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb91808d38476e2a469dcdd4dbd12eb5">&#9670;&#160;</a></span>gaussian_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hila::gaussian_random </td>
          <td>(</td>
          <td class="paramtype">out_only T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template function const T &amp; <a class="el" href="namespacehila.html#afb91808d38476e2a469dcdd4dbd12eb5">hila::gaussian_random</a>(T &amp; variable,double width=1) Sets the argument to a gaussian random value, and return a constant reference to it. Optional second argument width sets the variance=width^2 (default=1)</p>
<p>Example: Complex&lt;double&gt; c; auto n = sqr(hila::gaussian_random(c)); sets the variable c to complex gaussian random value and stores its square in n.</p>
<p>For hila classes relies on the existence of method T::gaussian_random().</p>
<p>Advantage over class function T::random() is that the argument can be of elementary arithmetic type. </p>

<p class="definition">Definition at line <a class="el" href="random_8h_source.html#l00152">152</a> of file <a class="el" href="random_8h_source.html">random.h</a>.</p>

</div>
</div>
<a id="a61c7a1986bda1135c33fd13d0274a353" name="a61c7a1986bda1135c33fd13d0274a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c7a1986bda1135c33fd13d0274a353">&#9670;&#160;</a></span>gaussrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hila::gaussrand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacehila.html#a61c7a1986bda1135c33fd13d0274a353">hila::gaussrand()</a> returns a Gaussian distributed random number with variance 1.0, i.e. the probability distribution is exp( -x*x/2 ), so &lt; x^2 &gt; = 1 If you want random numbers with variance sigma, multiply the result by sqrt(sigma): sqrt(sigma) * <a class="el" href="namespacehila.html#a61c7a1986bda1135c33fd13d0274a353">gaussrand()</a>; </p>

<p class="definition">Definition at line <a class="el" href="random_8cpp_source.html#l00183">183</a> of file <a class="el" href="random_8cpp_source.html">random.cpp</a>.</p>

</div>
</div>
<a id="accb26f4a0a9d307c964e16f77239a960" name="accb26f4a0a9d307c964e16f77239a960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb26f4a0a9d307c964e16f77239a960">&#9670;&#160;</a></span>gaussrand2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hila::gaussrand2 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>out2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacehila.html#accb26f4a0a9d307c964e16f77239a960">hila::gaussrand2</a> returns 2 Gaussian distributed random numbers with variance 1.0. Useful because Box-Muller algorithm computes 2 values at the same time. </p>

<p class="definition">Definition at line <a class="el" href="random_8cpp_source.html#l00166">166</a> of file <a class="el" href="random_8cpp_source.html">random.cpp</a>.</p>

</div>
</div>
<a id="a6d0fc8cf25aca41ceac7aae4e5636064" name="a6d0fc8cf25aca41ceac7aae4e5636064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0fc8cf25aca41ceac7aae4e5636064">&#9670;&#160;</a></span>get_complex_in_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; <a class="el" href="structhila_1_1contains__complex.html">hila::contains_complex</a>&lt; T &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComplex.html">Complex</a>&lt; hila::scalar_type&lt; T &gt; &gt; hila::get_complex_in_var </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>as_complex_array(T var) casts the var to a pointer to complex&lt;scalar_type&lt;T&gt;&gt; assuming var contains complex type. This enables access of complex elements as as_complex_array(var)[i] comment out as hilapp gets confused at the moment get_complex_element(var,i) returns the i:th complex number embedded in variable v set_complex_element(var,i,value) sets the i:th element in var </p>

<p class="definition">Definition at line <a class="el" href="cmplx_8h_source.html#l00427">427</a> of file <a class="el" href="cmplx_8h_source.html">cmplx.h</a>.</p>

</div>
</div>
<a id="a74749529ceb2982ea9d68b53214f809c" name="a74749529ceb2982ea9d68b53214f809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74749529ceb2982ea9d68b53214f809c">&#9670;&#160;</a></span>get_number_in_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hila::scalar_type&lt; T &gt; hila::get_number_in_var </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access variables as if arrays of scalar_type numbers </p>

<p class="definition">Definition at line <a class="el" href="type__tools_8h_source.html#l00118">118</a> of file <a class="el" href="type__tools_8h_source.html">type_tools.h</a>.</p>

</div>
</div>
<a id="aa72756504f7ee068ec0b90fedfd07bfc" name="aa72756504f7ee068ec0b90fedfd07bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72756504f7ee068ec0b90fedfd07bfc">&#9670;&#160;</a></span>gettime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hila::gettime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use clock_gettime() to get the accurate time (alternative: use gettimeofday() or MPI_Wtime()) gettime returns the time in secs since program start </p>

<p class="definition">Definition at line <a class="el" href="timing_8cpp_source.html#l00144">144</a> of file <a class="el" href="timing_8cpp_source.html">timing.cpp</a>.</p>

</div>
</div>
<a id="a88d54715010ef67cf2fbea84b00f76bb" name="a88d54715010ef67cf2fbea84b00f76bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d54715010ef67cf2fbea84b00f76bb">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in command line arguments. Initialise default stream and MPI communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Number of command line arguments </td></tr>
    <tr><td class="paramname">argv</td><td>List of command line arguments </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="initialize_8cpp_source.html#l00174">174</a> of file <a class="el" href="initialize_8cpp_source.html">initialize.cpp</a>.</p>

</div>
</div>
<a id="a17c785c728099c66865b717aebe26cdc" name="a17c785c728099c66865b717aebe26cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c785c728099c66865b717aebe26cdc">&#9670;&#160;</a></span>initialize_device_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::initialize_device_rng </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize device random number generator on GPUs, if on GPU platform. No effect on other archs. On MPI shuffles the seed for different MPI ranks. Called by <a class="el" href="namespacehila.html#a90e5e5f9365383ef279039371798f09b">seed_random()</a> unless its 2nd argument is hila::device_rng_off. This can reinitialize device RNG free'd by <a class="el" href="namespacehila.html#a2a51f6f0888abf848ad7c4503a84d4ee" title="Def here gpu rng functions for non-gpu.">free_device_rng()</a>. </p>

<p class="definition">Definition at line <a class="el" href="hila__gpu_8cpp_source.html#l00070">70</a> of file <a class="el" href="hila__gpu_8cpp_source.html">hila_gpu.cpp</a>.</p>

</div>
</div>
<a id="aac91b8ebf153265b88955796ebd12a5f" name="aac91b8ebf153265b88955796ebd12a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac91b8ebf153265b88955796ebd12a5f">&#9670;&#160;</a></span>initialize_host_rng()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::initialize_host_rng </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize host (CPU) random number generator separately, done implicitly by <a class="el" href="namespacehila.html#a90e5e5f9365383ef279039371798f09b">seed_random()</a> Parameter random number seed. On MPI shuffles different seed values for all MPI ranks. </p>

<p class="definition">Definition at line <a class="el" href="random_8cpp_source.html#l00059">59</a> of file <a class="el" href="random_8cpp_source.html">random.cpp</a>.</p>

</div>
</div>
<a id="a342d541c70e0e4756dfdd9dbf4c2b9c5" name="a342d541c70e0e4756dfdd9dbf4c2b9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342d541c70e0e4756dfdd9dbf4c2b9c5">&#9670;&#160;</a></span>myrank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hila::myrank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rank of this node </p>
<p>Return my node number - take care to return the previous node number if mpi is being torn down (used in destructors) </p>

<p class="definition">Definition at line <a class="el" href="com__mpi_8cpp_source.html#l00235">235</a> of file <a class="el" href="com__mpi_8cpp_source.html">com_mpi.cpp</a>.</p>

</div>
</div>
<a id="a46617d8162267096e14c8b0046a15fa6" name="a46617d8162267096e14c8b0046a15fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46617d8162267096e14c8b0046a15fa6">&#9670;&#160;</a></span>number_of_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hila::number_of_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how many nodes there are </p>
<p>Return number of nodes or "pseudo-nodes". </p>

<p class="definition">Definition at line <a class="el" href="com__mpi_8cpp_source.html#l00246">246</a> of file <a class="el" href="com__mpi_8cpp_source.html">com_mpi.cpp</a>.</p>

</div>
</div>
<a id="a619e441d1ebadab1a5d1d3f08b88fb42" name="a619e441d1ebadab1a5d1d3f08b88fb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e441d1ebadab1a5d1d3f08b88fb42">&#9670;&#160;</a></span>random() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hila::random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random()</a> returns a uniform double precision random number in interval [0,1). Can be called from outside or inside site loops (on GPU if the device rng is initialized) </p>

<p class="definition">Definition at line <a class="el" href="hila__gpu_8cpp_source.html#l00118">118</a> of file <a class="el" href="hila__gpu_8cpp_source.html">hila_gpu.cpp</a>.</p>

</div>
</div>
<a id="a9992a0fa128b359eba5eaa845d0b4f2e" name="a9992a0fa128b359eba5eaa845d0b4f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9992a0fa128b359eba5eaa845d0b4f2e">&#9670;&#160;</a></span>random() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hila::random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template function T <a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random&lt;T&gt;()</a>; without argument. This is used to generate random value for T without defined variable. Example: auto n = <a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random&lt;Complex&lt;double&gt;&gt;()</a>.abs(); calculates the norm of a random complex value.</p>
<p><a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random&lt;double&gt;()</a> is functionally equivalent to <a class="el" href="namespacehila.html#a619e441d1ebadab1a5d1d3f08b88fb42">hila::random()</a> </p>

<p class="definition">Definition at line <a class="el" href="random_8h_source.html#l00128">128</a> of file <a class="el" href="random_8h_source.html">random.h</a>.</p>

</div>
</div>
<a id="a185aa8fbf7349f39877175789e74f709" name="a185aa8fbf7349f39877175789e74f709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185aa8fbf7349f39877175789e74f709">&#9670;&#160;</a></span>random() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T hila::random </td>
          <td>(</td>
          <td class="paramtype">out_only T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Template function const T &amp; hila::random(T &amp; var) Sets the argument to a random value, and return a constant reference to it. Example: Complex&lt;double&gt; c; auto n = hila::random(c).abs(); sets the variable c to complex random value and calculates its absolute value. c.real() and c.imag() will be \in [0,1)</p>
<p>For hila classes relies on the existence of method T::random() (i.e. var.random())</p>
<p>Typically sets the argument real numbers to interval [0,1), but not always: for example, if T is SU&lt;N,T&gt; -matrix sets the argument to valid random SU&lt;N,T&gt;.</p>
<p>Advantage over class function T::random() is that the argument can be of elementary arithmetic type. </p>

<p class="definition">Definition at line <a class="el" href="random_8h_source.html#l00106">106</a> of file <a class="el" href="random_8h_source.html">random.h</a>.</p>

</div>
</div>
<a id="a90e5e5f9365383ef279039371798f09b" name="a90e5e5f9365383ef279039371798f09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e5e5f9365383ef279039371798f09b">&#9670;&#160;</a></span>seed_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::seed_random </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>device_init</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seed random generators with 64-bit unsigned value. On MPI shuffles the seed so that different MPI ranks are seeded with different values.</p>
<p>The optional 2nd argument indicates whether to initialize the RNG on GPU device: hila::device_rng_on (default) or hila::device_rng_off. This argument does nothing if not GPU platform. If hila::device_rng_off is used, onsites() -loops cannot contain random number calls (Runtime error will be flagged and program exits).</p>
<p>Seed random number generators Seed is shuffled so that different nodes get different rng seeds. If seed == 0, generate seed using the time() -function. </p>

<p class="definition">Definition at line <a class="el" href="random_8cpp_source.html#l00078">78</a> of file <a class="el" href="random_8cpp_source.html">random.cpp</a>.</p>

</div>
</div>
<a id="adf07345c02b82159a0e7d0ee91f0cf34" name="adf07345c02b82159a0e7d0ee91f0cf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf07345c02b82159a0e7d0ee91f0cf34">&#9670;&#160;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hila::terminate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force quit for multinode processes &ndash; kill all nodes No synchronisation done </p>

<p class="definition">Definition at line <a class="el" href="initialize_8cpp_source.html#l00367">367</a> of file <a class="el" href="initialize_8cpp_source.html">initialize.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehila.html">hila</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: The First Group</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group1.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The First Group</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8bd359026366c3e072d372e4fd7ab5a"><td class="memItemLeft" align="right" valign="top"><a id="gaa8bd359026366c3e072d372e4fd7ab5a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaa8bd359026366c3e072d372e4fd7ab5a">Field&lt; T &gt;::field_struct::get</a> (const unsigned i) const</td></tr>
<tr class="memdesc:gaa8bd359026366c3e072d372e4fd7ab5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for an individual elements in a loop. <br /></td></tr>
<tr class="separator:gaa8bd359026366c3e072d372e4fd7ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196d5fe59c0d72d1342de3d85a39fdc7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga196d5fe59c0d72d1342de3d85a39fdc7">Field&lt; T &gt;::field_struct::get_element</a> (const unsigned i) const</td></tr>
<tr class="separator:ga196d5fe59c0d72d1342de3d85a39fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201c0e04cb2085ae8b70bf489483156a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga201c0e04cb2085ae8b70bf489483156a">Field&lt; T &gt;::field_struct::gather_comm_elements</a> (Direction d, Parity par, T *RESTRICT buffer, const <a class="el" href="structlattice__struct_1_1comm__node__struct.html">lattice_struct::comm_node_struct</a> &amp;to_node) const</td></tr>
<tr class="memdesc:ga201c0e04cb2085ae8b70bf489483156a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather boundary elements for communication.  <a href="group__group1.html#ga201c0e04cb2085ae8b70bf489483156a">More...</a><br /></td></tr>
<tr class="separator:ga201c0e04cb2085ae8b70bf489483156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6d7becb7f52d90d06ceb2515ef7299"><td class="memItemLeft" align="right" valign="top"><a id="gaaf6d7becb7f52d90d06ceb2515ef7299"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaaf6d7becb7f52d90d06ceb2515ef7299">Field&lt; T &gt;::field_struct::place_comm_elements</a> (Direction d, Parity par, T *RESTRICT buffer, const <a class="el" href="structlattice__struct_1_1comm__node__struct.html">lattice_struct::comm_node_struct</a> &amp;from_node)</td></tr>
<tr class="memdesc:gaaf6d7becb7f52d90d06ceb2515ef7299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place boundary elements from neighbour. <br /></td></tr>
<tr class="separator:gaaf6d7becb7f52d90d06ceb2515ef7299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd784126b28d2091baf9e0f0cd5290e"><td class="memItemLeft" align="right" valign="top"><a id="ga5cd784126b28d2091baf9e0f0cd5290e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga5cd784126b28d2091baf9e0f0cd5290e">Field&lt; T &gt;::field_struct::set_local_boundary_elements</a> (Direction dir, Parity par)</td></tr>
<tr class="memdesc:ga5cd784126b28d2091baf9e0f0cd5290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place boundary elements from local lattice (used in vectorized version) <br /></td></tr>
<tr class="separator:ga5cd784126b28d2091baf9e0f0cd5290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75669289a7276b95aad496963cab33a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaa75669289a7276b95aad496963cab33a">Field&lt; T &gt;::field_struct::gather_elements</a> (T *buffer, const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;coord_list, int root=0) const</td></tr>
<tr class="memdesc:gaa75669289a7276b95aad496963cab33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather a list of elements to a single node.  <a href="group__group1.html#gaa75669289a7276b95aad496963cab33a">More...</a><br /></td></tr>
<tr class="separator:gaa75669289a7276b95aad496963cab33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08484f91239ab8f86dfebe2494207673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga08484f91239ab8f86dfebe2494207673">Field&lt; T &gt;::field_struct::scatter_elements</a> (T *buffer, const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;coord_list, int root=0)</td></tr>
<tr class="separator:ga08484f91239ab8f86dfebe2494207673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1629cc2ae98abdfe156cf4e2d76565"><td class="memItemLeft" align="right" valign="top"><a id="gaad1629cc2ae98abdfe156cf4e2d76565"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaad1629cc2ae98abdfe156cf4e2d76565">Field&lt; T &gt;::field_struct::get_receive_buffer</a> (Direction d, Parity par, const <a class="el" href="structlattice__struct_1_1comm__node__struct.html">lattice_struct::comm_node_struct</a> &amp;from_node)</td></tr>
<tr class="memdesc:gaad1629cc2ae98abdfe156cf4e2d76565"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the receive buffer pointer for the communication. <br /></td></tr>
<tr class="separator:gaad1629cc2ae98abdfe156cf4e2d76565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76a0477380e02532746853d16983c4a"><td class="memItemLeft" align="right" valign="top">dir_mask_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gac76a0477380e02532746853d16983c4a">Field&lt; T &gt;::start_gather</a> (Direction d, Parity p=ALL) const</td></tr>
<tr class="memdesc:gac76a0477380e02532746853d16983c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication routines.  <a href="group__group1.html#gac76a0477380e02532746853d16983c4a">More...</a><br /></td></tr>
<tr class="separator:gac76a0477380e02532746853d16983c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab039d34f2e65c9cd58326fd013efd90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gab039d34f2e65c9cd58326fd013efd90c">Field&lt; T &gt;::wait_gather</a> (Direction d, Parity p) const</td></tr>
<tr class="separator:gab039d34f2e65c9cd58326fd013efd90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fc62db1df52e6c69f9a9328b74921e"><td class="memItemLeft" align="right" valign="top"><a id="ga12fc62db1df52e6c69f9a9328b74921e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga12fc62db1df52e6c69f9a9328b74921e">Field&lt; T &gt;::gather</a> (Direction d, Parity p=ALL) const</td></tr>
<tr class="memdesc:ga12fc62db1df52e6c69f9a9328b74921e"><td class="mdescLeft">&#160;</td><td class="mdescRight">And a convenience combi function. <br /></td></tr>
<tr class="separator:ga12fc62db1df52e6c69f9a9328b74921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeefcc169a728e8ead3e13961926e689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gabeefcc169a728e8ead3e13961926e689">Field&lt; T &gt;::drop_comms</a> (Direction d, Parity p) const</td></tr>
<tr class="separator:gabeefcc169a728e8ead3e13961926e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea30d8bfc43c059834bf931328796fdd"><td class="memItemLeft" align="right" valign="top"><a id="gaea30d8bfc43c059834bf931328796fdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaea30d8bfc43c059834bf931328796fdd">Field&lt; T &gt;::cancel_comm</a> (Direction d, Parity p) const</td></tr>
<tr class="memdesc:gaea30d8bfc43c059834bf931328796fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">cancel ongoing send and receive <br /></td></tr>
<tr class="separator:gaea30d8bfc43c059834bf931328796fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructor</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp678d0a4421b60dc59999ac02837496a6"></a>Destroy the <a class="el" href="classField.html" title="something">Field</a> object </p>
</td></tr>
<tr class="memitem:gaf8bddef661162866b411f4d6a1c15933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaf8bddef661162866b411f4d6a1c15933">Field&lt; T &gt;::operator=</a> (const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf8bddef661162866b411f4d6a1c15933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic assignment operator.  <a href="group__group1.html#gaf8bddef661162866b411f4d6a1c15933">More...</a><br /></td></tr>
<tr class="separator:gaf8bddef661162866b411f4d6a1c15933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dcb5eb859fdf4d52210d3161b626e1"><td class="memTemplParams" colspan="2"><a id="ga45dcb5eb859fdf4d52210d3161b626e1"></a>
template&lt;typename A , std::enable_if_t&lt; hila::is_assignable&lt; T &amp;, A &gt;::value||std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga45dcb5eb859fdf4d52210d3161b626e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator=</b> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="separator:ga45dcb5eb859fdf4d52210d3161b626e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb586ef0d3d20189496f31ec01115d49"><td class="memTemplParams" colspan="2"><a id="gadb586ef0d3d20189496f31ec01115d49"></a>
template&lt;typename A , std::enable_if_t&lt; hila::is_assignable&lt; T &amp;, A &gt;::value||std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gadb586ef0d3d20189496f31ec01115d49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator=</b> (const A &amp;d)</td></tr>
<tr class="separator:gadb586ef0d3d20189496f31ec01115d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869022c3348374e732ddf5ccb10e1174"><td class="memItemLeft" align="right" valign="top"><a id="ga869022c3348374e732ddf5ccb10e1174"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::operator=</b> (const std::nullptr_t &amp;z)</td></tr>
<tr class="separator:ga869022c3348374e732ddf5ccb10e1174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fdf000cbe9b76eb266f46fcb5c7d272"><td class="memItemLeft" align="right" valign="top"><a id="ga0fdf000cbe9b76eb266f46fcb5c7d272"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::operator=</b> (<a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&amp;rhs)</td></tr>
<tr class="separator:ga0fdf000cbe9b76eb266f46fcb5c7d272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac53ac99d4eaa19063eb5ee61784a2bc0"><td class="memTemplParams" colspan="2"><a id="gac53ac99d4eaa19063eb5ee61784a2bc0"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_plus&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gac53ac99d4eaa19063eb5ee61784a2bc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator+=</b> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="separator:gac53ac99d4eaa19063eb5ee61784a2bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfbd8a4666b06d16c5929aaad5c9cf5"><td class="memTemplParams" colspan="2"><a id="ga6cfbd8a4666b06d16c5929aaad5c9cf5"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_minus&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga6cfbd8a4666b06d16c5929aaad5c9cf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator-=</b> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="separator:ga6cfbd8a4666b06d16c5929aaad5c9cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad889649ea2957d9727c7a4e18b978aee"><td class="memTemplParams" colspan="2"><a id="gad889649ea2957d9727c7a4e18b978aee"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_mul&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gad889649ea2957d9727c7a4e18b978aee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator*=</b> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="separator:gad889649ea2957d9727c7a4e18b978aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5943f413527433fc25c2f1f4e267d5f"><td class="memTemplParams" colspan="2"><a id="gac5943f413527433fc25c2f1f4e267d5f"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_div&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gac5943f413527433fc25c2f1f4e267d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator/=</b> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="separator:gac5943f413527433fc25c2f1f4e267d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fcc9ba9f7ab860fe92b4b694753c305"><td class="memTemplParams" colspan="2"><a id="ga5fcc9ba9f7ab860fe92b4b694753c305"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_plus&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga5fcc9ba9f7ab860fe92b4b694753c305"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator+=</b> (const A &amp;rhs)</td></tr>
<tr class="separator:ga5fcc9ba9f7ab860fe92b4b694753c305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae856e045808a62f92ef5a06b912cc5de"><td class="memTemplParams" colspan="2"><a id="gae856e045808a62f92ef5a06b912cc5de"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_minus&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gae856e045808a62f92ef5a06b912cc5de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator-=</b> (const A &amp;rhs)</td></tr>
<tr class="separator:gae856e045808a62f92ef5a06b912cc5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05abe9d3a951ad4568c3b889c5ce0ada"><td class="memTemplParams" colspan="2"><a id="ga05abe9d3a951ad4568c3b889c5ce0ada"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_mul&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga05abe9d3a951ad4568c3b889c5ce0ada"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator*=</b> (const A &amp;rhs)</td></tr>
<tr class="separator:ga05abe9d3a951ad4568c3b889c5ce0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c50bda5b7216351be299b2de2cedc4"><td class="memTemplParams" colspan="2"><a id="gac1c50bda5b7216351be299b2de2cedc4"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; hila::type_div&lt; T, A &gt;, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gac1c50bda5b7216351be299b2de2cedc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::operator/=</b> (const A &amp;rhs)</td></tr>
<tr class="separator:gac1c50bda5b7216351be299b2de2cedc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9adcf36df44735d4084dcf4222925e"><td class="memItemLeft" align="right" valign="top"><a id="gadb9adcf36df44735d4084dcf4222925e"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::operator+</b> () const</td></tr>
<tr class="separator:gadb9adcf36df44735d4084dcf4222925e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f91515dc10feabb652c9020a270899e"><td class="memItemLeft" align="right" valign="top"><a id="ga7f91515dc10feabb652c9020a270899e"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::operator-</b> () const</td></tr>
<tr class="separator:ga7f91515dc10feabb652c9020a270899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2eac523e03a798075ad49784a8d7d8"><td class="memItemLeft" align="right" valign="top"><a id="gaaf2eac523e03a798075ad49784a8d7d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::operator==</b> (const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="separator:gaaf2eac523e03a798075ad49784a8d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa6d14bb95a5d0397041c576bfd56d8"><td class="memItemLeft" align="right" valign="top"><a id="gabfa6d14bb95a5d0397041c576bfd56d8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::squarenorm</b> () const</td></tr>
<tr class="separator:gabfa6d14bb95a5d0397041c576bfd56d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57664b8a8651e128b7d1dc260581f36c"><td class="memItemLeft" align="right" valign="top"><a id="ga57664b8a8651e128b7d1dc260581f36c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::norm</b> ()</td></tr>
<tr class="separator:ga57664b8a8651e128b7d1dc260581f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542978290ca94afdf5d8698841947e50"><td class="memItemLeft" align="right" valign="top"><a id="ga542978290ca94afdf5d8698841947e50"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::conj</b> () const</td></tr>
<tr class="separator:ga542978290ca94afdf5d8698841947e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd8cf07a41fd1288941e5079ffd6189"><td class="memTemplParams" colspan="2"><a id="gaebd8cf07a41fd1288941e5079ffd6189"></a>
template&lt;typename R  = T, typename A  = decltype(::dagger(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:gaebd8cf07a41fd1288941e5079ffd6189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::dagger</b> () const</td></tr>
<tr class="separator:gaebd8cf07a41fd1288941e5079ffd6189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88109bc12df20ee3e613f275a9f42378"><td class="memTemplParams" colspan="2"><a id="ga88109bc12df20ee3e613f275a9f42378"></a>
template&lt;typename R  = T, typename A  = decltype(::real(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:ga88109bc12df20ee3e613f275a9f42378"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::real</b> () const</td></tr>
<tr class="separator:ga88109bc12df20ee3e613f275a9f42378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1598efcf0df9eaa11f82d3784bcf4d35"><td class="memTemplParams" colspan="2"><a id="ga1598efcf0df9eaa11f82d3784bcf4d35"></a>
template&lt;typename R  = T, typename A  = decltype(::imag(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:ga1598efcf0df9eaa11f82d3784bcf4d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::imag</b> () const</td></tr>
<tr class="separator:ga1598efcf0df9eaa11f82d3784bcf4d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Shift operations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp096fc6394b549ec4342171c2b72c165f"></a>Create a periodically shifted copy of the field</p>
<p>this is currently OK only for short moves, very inefficient for longer moves </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr class="memitem:ga16909d25ad97e1a1289abba8d56bbb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga16909d25ad97e1a1289abba8d56bbb45">Field&lt; T &gt;::shift</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;v, <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;r, Parity par) const</td></tr>
<tr class="separator:ga16909d25ad97e1a1289abba8d56bbb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072de216a92c47ccca32b15fabfe5296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga072de216a92c47ccca32b15fabfe5296">Field&lt; T &gt;::shift</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;v, <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;r) const</td></tr>
<tr class="separator:ga072de216a92c47ccca32b15fabfe5296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a40a58d44e5b87e4189bf3242b79a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga8a40a58d44e5b87e4189bf3242b79a32">Field&lt; T &gt;::shift</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;v, Parity par) const</td></tr>
<tr class="separator:ga8a40a58d44e5b87e4189bf3242b79a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, A &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gabd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group1.html#gabd01a2a3e8b22665b12767bbc1d4a3b6">Field&lt; T &gt;::set_element</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;value)</td></tr>
<tr class="separator:gabd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f905efa61f6af54664845f72430d69"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga33f905efa61f6af54664845f72430d69">Field&lt; T &gt;::get_element</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord) const</td></tr>
<tr class="memdesc:ga33f905efa61f6af54664845f72430d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get singular element which will be broadcast to all nodes.  <a href="group__group1.html#ga33f905efa61f6af54664845f72430d69">More...</a><br /></td></tr>
<tr class="separator:ga33f905efa61f6af54664845f72430d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbc0520bbd1c40b8d5d5a4794ae0605"><td class="memItemLeft" align="right" valign="top"><a id="gaecbc0520bbd1c40b8d5d5a4794ae0605"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::set_elements</b> (const std::vector&lt; T &gt; &amp;elements, const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;coord_list)</td></tr>
<tr class="separator:gaecbc0520bbd1c40b8d5d5a4794ae0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62500759ad146835236688bfca45354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gae62500759ad146835236688bfca45354">Field&lt; T &gt;::get_elements</a> (const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;coord_list, bool broadcast=false) const</td></tr>
<tr class="memdesc:gae62500759ad146835236688bfca45354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves list of elements to all nodes.  <a href="group__group1.html#gae62500759ad146835236688bfca45354">More...</a><br /></td></tr>
<tr class="separator:gae62500759ad146835236688bfca45354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14250b89ec6fdb483bf70195f7a31124"><td class="memItemLeft" align="right" valign="top"><a id="ga14250b89ec6fdb483bf70195f7a31124"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga14250b89ec6fdb483bf70195f7a31124">Field&lt; T &gt;::get_subvolume</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmin, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmax, bool broadcast=false) const</td></tr>
<tr class="memdesc:ga14250b89ec6fdb483bf70195f7a31124"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a subvolume of the field elements to all nodes <br /></td></tr>
<tr class="separator:ga14250b89ec6fdb483bf70195f7a31124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47e166050f2c100782500c5eda41925"><td class="memItemLeft" align="right" valign="top"><a id="gaf47e166050f2c100782500c5eda41925"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaf47e166050f2c100782500c5eda41925">Field&lt; T &gt;::get_slice</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;c, bool broadcast=false) const</td></tr>
<tr class="memdesc:gaf47e166050f2c100782500c5eda41925"><td class="mdescLeft">&#160;</td><td class="mdescRight">and get a slice (subvolume) <br /></td></tr>
<tr class="separator:gaf47e166050f2c100782500c5eda41925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48de521e9e9beb5907351e7ee8721b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga48de521e9e9beb5907351e7ee8721b0e">Field&lt; T &gt;::copy_local_data</a> (std::vector&lt; T &gt; &amp;buffer) const</td></tr>
<tr class="separator:ga48de521e9e9beb5907351e7ee8721b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9786ec56558e6d5ba76fc2b7bc062e"><td class="memItemLeft" align="right" valign="top"><a id="gada9786ec56558e6d5ba76fc2b7bc062e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gada9786ec56558e6d5ba76fc2b7bc062e">Field&lt; T &gt;::set_local_data</a> (const std::vector&lt; T &gt; &amp;buffer)</td></tr>
<tr class="memdesc:gada9786ec56558e6d5ba76fc2b7bc062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the local data from an array <br /></td></tr>
<tr class="separator:gada9786ec56558e6d5ba76fc2b7bc062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309191896c609ab7f9eff093f5e63cbe"><td class="memItemLeft" align="right" valign="top"><a id="ga309191896c609ab7f9eff093f5e63cbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::copy_local_data_with_halo</b> (std::vector&lt; T &gt; &amp;buffer) const</td></tr>
<tr class="separator:ga309191896c609ab7f9eff093f5e63cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab270da5dd3546266f3a687e895ce1bfc"><td class="memTemplParams" colspan="2"><a id="gab270da5dd3546266f3a687e895ce1bfc"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, hila::type_plus&lt; T, A &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab270da5dd3546266f3a687e895ce1bfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::compound_add_element</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;av)</td></tr>
<tr class="separator:gab270da5dd3546266f3a687e895ce1bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae84ce10b52f2b193ed6c18ea4d45d57f"><td class="memTemplParams" colspan="2"><a id="gae84ce10b52f2b193ed6c18ea4d45d57f"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, hila::type_minus&lt; T, A &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gae84ce10b52f2b193ed6c18ea4d45d57f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::compound_sub_element</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;av)</td></tr>
<tr class="separator:gae84ce10b52f2b193ed6c18ea4d45d57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0199cfbd4332c20fd611004dfa6e2b5"><td class="memTemplParams" colspan="2"><a id="gab0199cfbd4332c20fd611004dfa6e2b5"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, hila::type_mul&lt; T, A &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab0199cfbd4332c20fd611004dfa6e2b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::compound_mul_element</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;av)</td></tr>
<tr class="separator:gab0199cfbd4332c20fd611004dfa6e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627e3f86fc76e5671d43af670d619b67"><td class="memTemplParams" colspan="2"><a id="ga627e3f86fc76e5671d43af670d619b67"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, hila::type_div&lt; T, A &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga627e3f86fc76e5671d43af670d619b67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::compound_div_element</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;av)</td></tr>
<tr class="separator:ga627e3f86fc76e5671d43af670d619b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3cadb538b1f703ef3dcab413b52712"><td class="memItemLeft" align="right" valign="top"><a id="gace3cadb538b1f703ef3dcab413b52712"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::FFT</b> (fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:gace3cadb538b1f703ef3dcab413b52712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d7d4e07765a8511ee7ea0922e35998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gac3d7d4e07765a8511ee7ea0922e35998">Field&lt; T &gt;::FFT</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;dirs, fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:gac3d7d4e07765a8511ee7ea0922e35998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59014eee111097c2214bea8327b0b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; <a class="el" href="classComplex.html">Complex</a>&lt; hila::number_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaf59014eee111097c2214bea8327b0b3d">Field&lt; T &gt;::FFT_real_to_complex</a> (fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:gaf59014eee111097c2214bea8327b0b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5eb8bf40360ecc12a58c8b28bb1a1b9"><td class="memItemLeft" align="right" valign="top"><a id="gaa5eb8bf40360ecc12a58c8b28bb1a1b9"></a>
<a class="el" href="classField.html">Field</a>&lt; hila::number_type&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::FFT_complex_to_real</b> (fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:gaa5eb8bf40360ecc12a58c8b28bb1a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e4f3837a00dc54a8b217aaff1ab774"><td class="memItemLeft" align="right" valign="top"><a id="ga09e4f3837a00dc54a8b217aaff1ab774"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::reflect</b> () const</td></tr>
<tr class="separator:ga09e4f3837a00dc54a8b217aaff1ab774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c809f231e2f56911106ea083fd4963"><td class="memItemLeft" align="right" valign="top"><a id="ga23c809f231e2f56911106ea083fd4963"></a>
<a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::reflect</b> (Direction dir) const</td></tr>
<tr class="separator:ga23c809f231e2f56911106ea083fd4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063e9cfeedb8a782e6d7461794db856e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga063e9cfeedb8a782e6d7461794db856e">Field&lt; T &gt;::reflect</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;dirs) const</td></tr>
<tr class="separator:ga063e9cfeedb8a782e6d7461794db856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d3528ee76668357b5a12aae4a0e2f6"><td class="memItemLeft" align="right" valign="top"><a id="gae3d3528ee76668357b5a12aae4a0e2f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gae3d3528ee76668357b5a12aae4a0e2f6">Field&lt; T &gt;::write</a> (std::ofstream &amp;outputfile, bool binary=true, int precision=8) const</td></tr>
<tr class="memdesc:gae3d3528ee76668357b5a12aae4a0e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the field to a file stream. <br /></td></tr>
<tr class="separator:gae3d3528ee76668357b5a12aae4a0e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa856799fed13dee1cd90a2e6cf9429c2"><td class="memItemLeft" align="right" valign="top"><a id="gaa856799fed13dee1cd90a2e6cf9429c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaa856799fed13dee1cd90a2e6cf9429c2">Field&lt; T &gt;::write</a> (const std::string &amp;filename, bool binary=true, int precision=8) const</td></tr>
<tr class="memdesc:gaa856799fed13dee1cd90a2e6cf9429c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the <a class="el" href="classField.html" title="something">Field</a> to a named file replacing the file. <br /></td></tr>
<tr class="separator:gaa856799fed13dee1cd90a2e6cf9429c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31e8d394963efc4827ff582abddaadc"><td class="memItemLeft" align="right" valign="top"><a id="gaf31e8d394963efc4827ff582abddaadc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaf31e8d394963efc4827ff582abddaadc">Field&lt; T &gt;::read</a> (std::ifstream &amp;inputfile)</td></tr>
<tr class="memdesc:gaf31e8d394963efc4827ff582abddaadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the <a class="el" href="classField.html" title="something">Field</a> from a stream. <br /></td></tr>
<tr class="separator:gaf31e8d394963efc4827ff582abddaadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e2ce95e755fd5975c6be991c49af4e"><td class="memItemLeft" align="right" valign="top"><a id="ga21e2ce95e755fd5975c6be991c49af4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::read</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:ga21e2ce95e755fd5975c6be991c49af4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5c03dc76de38ba2c953edf1e8ebb7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga2e5c03dc76de38ba2c953edf1e8ebb7b">Field&lt; T &gt;::write_subvolume</a> (std::ofstream &amp;outputfile, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmin, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmax, int precision=6) const</td></tr>
<tr class="separator:ga2e5c03dc76de38ba2c953edf1e8ebb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4786163728339bc0fa0f687fb5f84c1f"><td class="memItemLeft" align="right" valign="top"><a id="ga4786163728339bc0fa0f687fb5f84c1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::write_subvolume</b> (const std::string &amp;filenname, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmin, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmax, int precision=6) const</td></tr>
<tr class="separator:ga4786163728339bc0fa0f687fb5f84c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0b21c6e7761b9c298f55ca4ce1eee5"><td class="memTemplParams" colspan="2"><a id="gafd0b21c6e7761b9c298f55ca4ce1eee5"></a>
template&lt;typename Out &gt; </td></tr>
<tr class="memitem:gafd0b21c6e7761b9c298f55ca4ce1eee5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Field&lt; T &gt;::write_slice</b> (Out &amp;outputfile, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;slice, int precision=6) const</td></tr>
<tr class="separator:gafd0b21c6e7761b9c298f55ca4ce1eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc56e57700521944341ab83b81055a6"><td class="memItemLeft" align="right" valign="top"><a id="gaefc56e57700521944341ab83b81055a6"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::sum</b> (Parity par=Parity::all, bool allreduce=true) const</td></tr>
<tr class="separator:gaefc56e57700521944341ab83b81055a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e51f96cefd61059878be388b227b43"><td class="memItemLeft" align="right" valign="top"><a id="gab1e51f96cefd61059878be388b227b43"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::product</b> (Parity par=Parity::all, bool allreduce=true) const</td></tr>
<tr class="separator:gab1e51f96cefd61059878be388b227b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4369fa39e3ffbab5c4060251ca112c5a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga4369fa39e3ffbab5c4060251ca112c5a">Field&lt; T &gt;::gpu_minmax</a> (bool min_or_max, Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="separator:ga4369fa39e3ffbab5c4060251ca112c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece7ce9c8dc5bfb284f81f6b587cf50e"><td class="memItemLeft" align="right" valign="top"><a id="gaece7ce9c8dc5bfb284f81f6b587cf50e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaece7ce9c8dc5bfb284f81f6b587cf50e">Field&lt; T &gt;::min</a> (Parity par=ALL) const</td></tr>
<tr class="memdesc:gaece7ce9c8dc5bfb284f81f6b587cf50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:gaece7ce9c8dc5bfb284f81f6b587cf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff8d7931070925d976bfb359c615bb1"><td class="memItemLeft" align="right" valign="top"><a id="gaaff8d7931070925d976bfb359c615bb1"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#gaaff8d7931070925d976bfb359c615bb1">Field&lt; T &gt;::min</a> (<a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:gaaff8d7931070925d976bfb359c615bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:gaaff8d7931070925d976bfb359c615bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187172f3017c1a6559a2d6d5d0303c9e"><td class="memItemLeft" align="right" valign="top"><a id="ga187172f3017c1a6559a2d6d5d0303c9e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga187172f3017c1a6559a2d6d5d0303c9e">Field&lt; T &gt;::min</a> (Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:ga187172f3017c1a6559a2d6d5d0303c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:ga187172f3017c1a6559a2d6d5d0303c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48dd39975c2d78912f567eb45895020e"><td class="memItemLeft" align="right" valign="top"><a id="ga48dd39975c2d78912f567eb45895020e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga48dd39975c2d78912f567eb45895020e">Field&lt; T &gt;::max</a> (Parity par=ALL) const</td></tr>
<tr class="memdesc:ga48dd39975c2d78912f567eb45895020e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:ga48dd39975c2d78912f567eb45895020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0397b02410a4cb430901f448936318"><td class="memItemLeft" align="right" valign="top"><a id="ga0d0397b02410a4cb430901f448936318"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga0d0397b02410a4cb430901f448936318">Field&lt; T &gt;::max</a> (<a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:ga0d0397b02410a4cb430901f448936318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:ga0d0397b02410a4cb430901f448936318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514ecef03120e974a2da2cfcf800f4b8"><td class="memItemLeft" align="right" valign="top"><a id="ga514ecef03120e974a2da2cfcf800f4b8"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group1.html#ga514ecef03120e974a2da2cfcf800f4b8">Field&lt; T &gt;::max</a> (Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:ga514ecef03120e974a2da2cfcf800f4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:ga514ecef03120e974a2da2cfcf800f4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe9d33a7161b8514f8de29beefd4dd4"><td class="memItemLeft" align="right" valign="top"><a id="gaebe9d33a7161b8514f8de29beefd4dd4"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::minmax</b> (bool is_min, Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="separator:gaebe9d33a7161b8514f8de29beefd4dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0b32de62c7c55f05557a4fa17ecb5e"><td class="memItemLeft" align="right" valign="top"><a id="ga5a0b32de62c7c55f05557a4fa17ecb5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::random</b> ()</td></tr>
<tr class="separator:ga5a0b32de62c7c55f05557a4fa17ecb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa44045b4a5d0027cbe80f6ffe57c0072"><td class="memItemLeft" align="right" valign="top"><a id="gaa44045b4a5d0027cbe80f6ffe57c0072"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Field&lt; T &gt;::gaussian_random</b> (double width=1.0)</td></tr>
<tr class="separator:gaa44045b4a5d0027cbe80f6ffe57c0072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Standard arithmetic ops which fields should implement Not all are always callable, e.g. division may not be implemented by all field types</p>
<p>This is the first group </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga48de521e9e9beb5907351e7ee8721b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48de521e9e9beb5907351e7ee8721b0e">&#9670;&nbsp;</a></span>copy_local_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::copy_local_data </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the local (mpi process) data to a "logical array" on gpu code, copies to host </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00718">718</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="gabeefcc169a728e8ead3e13961926e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeefcc169a728e8ead3e13961926e689">&#9670;&nbsp;</a></span>drop_comms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::drop_comms </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__group1.html#gabeefcc169a728e8ead3e13961926e689">drop_comms()</a>: if field is changed or deleted, cancel ongoing communications. This should happen very seldom, only if there are "by-hand" start_gather operations and these are not needed </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l01474">1474</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="gac3d7d4e07765a8511ee7ea0922e35998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d7d4e07765a8511ee7ea0922e35998">&#9670;&nbsp;</a></span>FFT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::FFT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fft_direction&#160;</td>
          <td class="paramname"><em>fftdir</em> = <code>fft_direction::forward</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classField.html" title="something">Field</a> method for performing FFT res = a.FFT(); fftdir: fft_direction::forward (default) or fft_direction::back </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00421">421</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="gaf59014eee111097c2214bea8327b0b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59014eee111097c2214bea8327b0b3d">&#9670;&nbsp;</a></span>FFT_real_to_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; <a class="el" href="classComplex.html">Complex</a>&lt; hila::number_type&lt; T &gt; &gt; &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::FFT_real_to_complex </td>
          <td>(</td>
          <td class="paramtype">fft_direction&#160;</td>
          <td class="paramname"><em>fftdir</em> = <code>fft_direction::forward</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FFT_real_to_complex: <a class="el" href="classField.html" title="something">Field</a> must be a real-valued field, result is a complex-valued field of the same type Implemented just by doing a FFT with a complex field with im=0; fft_direction::back gives a complex conjugate of the forward transform Result is f(-x) = f(L - x) = f(x)^* </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00445">445</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="ga201c0e04cb2085ae8b70bf489483156a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201c0e04cb2085ae8b70bf489483156a">&#9670;&nbsp;</a></span>gather_comm_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::field_struct::gather_comm_elements </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *RESTRICT&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlattice__struct_1_1comm__node__struct.html">lattice_struct::comm_node_struct</a> &amp;&#160;</td>
          <td class="paramname"><em>to_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather boundary elements for communication. </p>
<p>This file collects implementations of field communication routines.</p>
<p>Gather boundary elements for communication </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00016">16</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="gaa75669289a7276b95aad496963cab33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75669289a7276b95aad496963cab33a">&#9670;&nbsp;</a></span>gather_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::field_struct::gather_elements </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather a list of elements to a single node. </p>
<p>Gather a list of elements to a single node coord_list must be same on all nodes, buffer is needed only on "root" </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00490">490</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="ga33f905efa61f6af54664845f72430d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f905efa61f6af54664845f72430d69">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get singular element which will be broadcast to all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>coordinate of which the element is fetched with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00877">877</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ga196d5fe59c0d72d1342de3d85a39fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga196d5fe59c0d72d1342de3d85a39fdc7">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classField.html">Field</a>&lt; T &gt;::field_struct::get_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for an element outside a loop. Used to manipulate the field directly outside loops. </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00139">139</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="gae62500759ad146835236688bfca45354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae62500759ad146835236688bfca45354">&#9670;&nbsp;</a></span>get_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_elements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves list of elements to all nodes. </p>
<p>Get a list of elements and store them into a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord_list</td><td>vector of coordinates which will be fetched </td></tr>
    <tr><td class="paramname">broadcast</td><td>if true then elements retrieved to root node will be broadcast to all nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; list of all elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00662">662</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="ga4369fa39e3ffbab5c4060251ca112c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4369fa39e3ffbab5c4060251ca112c5a">&#9670;&nbsp;</a></span>gpu_minmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classField.html">Field</a>&lt; T &gt;::gpu_minmax </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min_or_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare gpu_reduce here, defined only for GPU targets For internal use only, preferably </p>

<p class="definition">Definition at line <a class="el" href="gpu__reduction_8h_source.html#l01033">1033</a> of file <a class="el" href="gpu__reduction_8h_source.html">gpu_reduction.h</a>.</p>

</div>
</div>
<a id="gaf8bddef661162866b411f4d6a1c15933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8bddef661162866b411f4d6a1c15933">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt;T&gt;&amp; <a class="el" href="classField.html">Field</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00666">666</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ga063e9cfeedb8a782e6d7461794db856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga063e9cfeedb8a782e6d7461794db856e">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dirs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field&lt;T&gt;::reflect() reflects the field around the desired axis This is here because it uses similar communications as fft TODO: refactorise so that there is separate "make columns" class! </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00539">539</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="ga08484f91239ab8f86dfebe2494207673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08484f91239ab8f86dfebe2494207673">&#9670;&nbsp;</a></span>scatter_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::field_struct::scatter_elements </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send elements from a single node to a list of coordinates coord_list must be the same on all nodes, but buffer is needed only on "root"! </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00567">567</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="gabd01a2a3e8b22665b12767bbc1d4a3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd01a2a3e8b22665b12767bbc1d4a3b6">&#9670;&nbsp;</a></span>set_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, A &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::set_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a single element. Assuming that each node calls this with the same value, it is sufficient to set the element locally </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00862">862</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ga072de216a92c47ccca32b15fabfe5296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072de216a92c47ccca32b15fabfe5296">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt;T&gt;&amp; <a class="el" href="classField.html">Field</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section remark"><dt>Remarks</dt><dd>Overload of shift(const CoordinateVector &amp;v, Field&lt;T&gt; &amp;r, Parity par) with par=ALL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00846">846</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ga16909d25ad97e1a1289abba8d56bbb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16909d25ad97e1a1289abba8d56bbb45">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp; <a class="el" href="classField.html">Field</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section remark"><dt>Remarks</dt><dd>Forward decleration in <a class="el" href="field_8h.html">field.h</a> of the method defined in <a class="el" href="field__comm_8h.html">field_comm.h</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>make more advanced, switching to "global" move for long shifts </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td></td></tr>
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;&amp; returns a reference to res </dd></dl>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00162">162</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="ga8a40a58d44e5b87e4189bf3242b79a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a40a58d44e5b87e4189bf3242b79a32">&#9670;&nbsp;</a></span>shift() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Add remark in comparison to other version of shift </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l01463">1463</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="gac76a0477380e02532746853d16983c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76a0477380e02532746853d16983c4a">&#9670;&nbsp;</a></span>start_gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">dir_mask_t <a class="el" href="classField.html">Field</a>&lt; T &gt;::start_gather </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em> = <code>ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Communication routines. </p>
<p><a class="el" href="group__group1.html#gac76a0477380e02532746853d16983c4a" title="Communication routines.">start_gather()</a>: Communicate the field at Parity par from Direction d. Uses accessors to prevent dependency on the layout. return the Direction mask bits where something is happening </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00262">262</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="gab039d34f2e65c9cd58326fd013efd90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab039d34f2e65c9cd58326fd013efd90c">&#9670;&nbsp;</a></span>wait_gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::wait_gather </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group__group1.html#gab039d34f2e65c9cd58326fd013efd90c">wait_gather()</a>: Wait for communication at parity par from Direction d completes the communication in the function. If the communication has not started yet, also calls <a class="el" href="group__group1.html#gac76a0477380e02532746853d16983c4a" title="Communication routines.">start_gather()</a></p>
<p>NOTE: This will be called even if the field is marked const. Therefore this function is const, even though it does change the internal content of the field, the halo. From the point of view of the user, the value of the field does not change. </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00394">394</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="ga2e5c03dc76de38ba2c953edf1e8ebb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e5c03dc76de38ba2c953edf1e8ebb7b">&#9670;&nbsp;</a></span>write_subvolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::write_subvolume </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a "subspace" of the original lattice Each element is written on a single line TODO: more formatting? </p>

<p class="definition">Definition at line <a class="el" href="field__io_8h_source.html#l00215">215</a> of file <a class="el" href="field__io_8h_source.html">field_io.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>

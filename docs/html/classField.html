<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: Field&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classField.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classField-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Field&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>something  
 <a href="classField.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="field_8h_source.html">field.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac76a0477380e02532746853d16983c4a"><td class="memItemLeft" align="right" valign="top">dir_mask_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ac76a0477380e02532746853d16983c4a">start_gather</a> (Direction d, Parity p=ALL) const</td></tr>
<tr class="memdesc:ac76a0477380e02532746853d16983c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communication routines.  <br /></td></tr>
<tr class="separator:ac76a0477380e02532746853d16983c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab039d34f2e65c9cd58326fd013efd90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ab039d34f2e65c9cd58326fd013efd90c">wait_gather</a> (Direction d, Parity p) const</td></tr>
<tr class="separator:ab039d34f2e65c9cd58326fd013efd90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc62db1df52e6c69f9a9328b74921e"><td class="memItemLeft" align="right" valign="top"><a id="a12fc62db1df52e6c69f9a9328b74921e" name="a12fc62db1df52e6c69f9a9328b74921e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gather</b> (Direction d, Parity p=ALL) const</td></tr>
<tr class="memdesc:a12fc62db1df52e6c69f9a9328b74921e"><td class="mdescLeft">&#160;</td><td class="mdescRight">And a convenience combi function. <br /></td></tr>
<tr class="separator:a12fc62db1df52e6c69f9a9328b74921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeefcc169a728e8ead3e13961926e689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#abeefcc169a728e8ead3e13961926e689">drop_comms</a> (Direction d, Parity p) const</td></tr>
<tr class="separator:abeefcc169a728e8ead3e13961926e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea30d8bfc43c059834bf931328796fdd"><td class="memItemLeft" align="right" valign="top"><a id="aea30d8bfc43c059834bf931328796fdd" name="aea30d8bfc43c059834bf931328796fdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cancel_comm</b> (Direction d, Parity p) const</td></tr>
<tr class="memdesc:aea30d8bfc43c059834bf931328796fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">cancel ongoing send and receive <br /></td></tr>
<tr class="separator:aea30d8bfc43c059834bf931328796fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memTemplParams" colspan="2"><a id="abd01a2a3e8b22665b12767bbc1d4a3b6" name="abd01a2a3e8b22665b12767bbc1d4a3b6"></a>
template&lt;typename A , std::enable_if_t&lt; std::is_assignable&lt; T &amp;, A &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_element</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord, const A &amp;value)</td></tr>
<tr class="memdesc:abd01a2a3e8b22665b12767bbc1d4a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single element. Assuming that each node calls this with the same value, it is sufficient to set the element locally. <br /></td></tr>
<tr class="separator:abd01a2a3e8b22665b12767bbc1d4a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f905efa61f6af54664845f72430d69"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a33f905efa61f6af54664845f72430d69">get_element</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;coord) const</td></tr>
<tr class="memdesc:a33f905efa61f6af54664845f72430d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get singular element which will be broadcast to all nodes.  <br /></td></tr>
<tr class="separator:a33f905efa61f6af54664845f72430d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62500759ad146835236688bfca45354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ae62500759ad146835236688bfca45354">get_elements</a> (const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;coord_list, bool broadcast=false) const</td></tr>
<tr class="memdesc:ae62500759ad146835236688bfca45354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves list of elements to all nodes.  <br /></td></tr>
<tr class="separator:ae62500759ad146835236688bfca45354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14250b89ec6fdb483bf70195f7a31124"><td class="memItemLeft" align="right" valign="top"><a id="a14250b89ec6fdb483bf70195f7a31124" name="a14250b89ec6fdb483bf70195f7a31124"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_subvolume</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmin, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmax, bool broadcast=false) const</td></tr>
<tr class="memdesc:a14250b89ec6fdb483bf70195f7a31124"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a subvolume of the field elements to all nodes <br /></td></tr>
<tr class="separator:a14250b89ec6fdb483bf70195f7a31124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e166050f2c100782500c5eda41925"><td class="memItemLeft" align="right" valign="top"><a id="af47e166050f2c100782500c5eda41925" name="af47e166050f2c100782500c5eda41925"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_slice</b> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;c, bool broadcast=false) const</td></tr>
<tr class="memdesc:af47e166050f2c100782500c5eda41925"><td class="mdescLeft">&#160;</td><td class="mdescRight">and get a slice (subvolume) <br /></td></tr>
<tr class="separator:af47e166050f2c100782500c5eda41925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48de521e9e9beb5907351e7ee8721b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a48de521e9e9beb5907351e7ee8721b0e">copy_local_data</a> (std::vector&lt; T &gt; &amp;buffer) const</td></tr>
<tr class="separator:a48de521e9e9beb5907351e7ee8721b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9786ec56558e6d5ba76fc2b7bc062e"><td class="memItemLeft" align="right" valign="top"><a id="ada9786ec56558e6d5ba76fc2b7bc062e" name="ada9786ec56558e6d5ba76fc2b7bc062e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_local_data</b> (const std::vector&lt; T &gt; &amp;buffer)</td></tr>
<tr class="memdesc:ada9786ec56558e6d5ba76fc2b7bc062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the local data from an array <br /></td></tr>
<tr class="separator:ada9786ec56558e6d5ba76fc2b7bc062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d7d4e07765a8511ee7ea0922e35998"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ac3d7d4e07765a8511ee7ea0922e35998">FFT</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;dirs, fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:ac3d7d4e07765a8511ee7ea0922e35998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d7704bd2de4fdfff86808f7cb27f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; <a class="el" href="classComplex.html">Complex</a>&lt; hila::scalar_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ab6d7704bd2de4fdfff86808f7cb27f04">FFT_real_to_complex</a> (fft_direction fdir=fft_direction::forward) const</td></tr>
<tr class="separator:ab6d7704bd2de4fdfff86808f7cb27f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e9cfeedb8a782e6d7461794db856e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a063e9cfeedb8a782e6d7461794db856e">reflect</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;dirs) const</td></tr>
<tr class="separator:a063e9cfeedb8a782e6d7461794db856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d3528ee76668357b5a12aae4a0e2f6"><td class="memItemLeft" align="right" valign="top"><a id="ae3d3528ee76668357b5a12aae4a0e2f6" name="ae3d3528ee76668357b5a12aae4a0e2f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (std::ofstream &amp;outputfile, bool binary=true, int precision=8) const</td></tr>
<tr class="memdesc:ae3d3528ee76668357b5a12aae4a0e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the field to a file stream. <br /></td></tr>
<tr class="separator:ae3d3528ee76668357b5a12aae4a0e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa856799fed13dee1cd90a2e6cf9429c2"><td class="memItemLeft" align="right" valign="top"><a id="aa856799fed13dee1cd90a2e6cf9429c2" name="aa856799fed13dee1cd90a2e6cf9429c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const std::string &amp;filename, bool binary=true, int precision=8) const</td></tr>
<tr class="memdesc:aa856799fed13dee1cd90a2e6cf9429c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the <a class="el" href="classField.html" title="something">Field</a> to a named file replacing the file. <br /></td></tr>
<tr class="separator:aa856799fed13dee1cd90a2e6cf9429c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e8d394963efc4827ff582abddaadc"><td class="memItemLeft" align="right" valign="top"><a id="af31e8d394963efc4827ff582abddaadc" name="af31e8d394963efc4827ff582abddaadc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (std::ifstream &amp;inputfile)</td></tr>
<tr class="memdesc:af31e8d394963efc4827ff582abddaadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the <a class="el" href="classField.html" title="something">Field</a> from a stream. <br /></td></tr>
<tr class="separator:af31e8d394963efc4827ff582abddaadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c03dc76de38ba2c953edf1e8ebb7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a2e5c03dc76de38ba2c953edf1e8ebb7b">write_subvolume</a> (std::ofstream &amp;outputfile, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmin, const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;cmax, int precision=6) const</td></tr>
<tr class="separator:a2e5c03dc76de38ba2c953edf1e8ebb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4369fa39e3ffbab5c4060251ca112c5a"><td class="memItemLeft" align="right" valign="top"><a id="a4369fa39e3ffbab5c4060251ca112c5a" name="a4369fa39e3ffbab5c4060251ca112c5a"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>gpu_minmax</b> (bool min_or_max, Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:a4369fa39e3ffbab5c4060251ca112c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare gpu_reduce here, defined only for GPU targets For internal use only, preferably. <br /></td></tr>
<tr class="separator:a4369fa39e3ffbab5c4060251ca112c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7ce9c8dc5bfb284f81f6b587cf50e"><td class="memItemLeft" align="right" valign="top"><a id="aece7ce9c8dc5bfb284f81f6b587cf50e" name="aece7ce9c8dc5bfb284f81f6b587cf50e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (Parity par=ALL) const</td></tr>
<tr class="memdesc:aece7ce9c8dc5bfb284f81f6b587cf50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:aece7ce9c8dc5bfb284f81f6b587cf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff8d7931070925d976bfb359c615bb1"><td class="memItemLeft" align="right" valign="top"><a id="aaff8d7931070925d976bfb359c615bb1" name="aaff8d7931070925d976bfb359c615bb1"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (<a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:aaff8d7931070925d976bfb359c615bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:aaff8d7931070925d976bfb359c615bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187172f3017c1a6559a2d6d5d0303c9e"><td class="memItemLeft" align="right" valign="top"><a id="a187172f3017c1a6559a2d6d5d0303c9e" name="a187172f3017c1a6559a2d6d5d0303c9e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:a187172f3017c1a6559a2d6d5d0303c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find minimum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:a187172f3017c1a6559a2d6d5d0303c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dd39975c2d78912f567eb45895020e"><td class="memItemLeft" align="right" valign="top"><a id="a48dd39975c2d78912f567eb45895020e" name="a48dd39975c2d78912f567eb45895020e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (Parity par=ALL) const</td></tr>
<tr class="memdesc:a48dd39975c2d78912f567eb45895020e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:a48dd39975c2d78912f567eb45895020e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0397b02410a4cb430901f448936318"><td class="memItemLeft" align="right" valign="top"><a id="a0d0397b02410a4cb430901f448936318" name="a0d0397b02410a4cb430901f448936318"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (<a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:a0d0397b02410a4cb430901f448936318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:a0d0397b02410a4cb430901f448936318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514ecef03120e974a2da2cfcf800f4b8"><td class="memItemLeft" align="right" valign="top"><a id="a514ecef03120e974a2da2cfcf800f4b8" name="a514ecef03120e974a2da2cfcf800f4b8"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (Parity par, <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;loc) const</td></tr>
<tr class="memdesc:a514ecef03120e974a2da2cfcf800f4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find maximum value and location from <a class="el" href="classField.html" title="something">Field</a>. <br /></td></tr>
<tr class="separator:a514ecef03120e974a2da2cfcf800f4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a05c4ad5e101c1d79a90f8a9d92e0069b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a05c4ad5e101c1d79a90f8a9d92e0069b">Field</a> ()</td></tr>
<tr class="memdesc:a05c4ad5e101c1d79a90f8a9d92e0069b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a new <a class="el" href="classField.html" title="something">Field</a> object.  <br /></td></tr>
<tr class="separator:a05c4ad5e101c1d79a90f8a9d92e0069b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522b40a16a45ee82cc0e4f22e5bf8bb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a522b40a16a45ee82cc0e4f22e5bf8bb3">Field</a> (const <a class="el" href="classField.html">Field</a> &amp;other)</td></tr>
<tr class="memdesc:a522b40a16a45ee82cc0e4f22e5bf8bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with already initialised <a class="el" href="classField.html" title="something">Field</a>.  <br /></td></tr>
<tr class="separator:a522b40a16a45ee82cc0e4f22e5bf8bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995954d6f5b9afbb61c97d26ede30245"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a995954d6f5b9afbb61c97d26ede30245"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classField.html#a995954d6f5b9afbb61c97d26ede30245">Field</a> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;other)</td></tr>
<tr class="memdesc:a995954d6f5b9afbb61c97d26ede30245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor form <a class="el" href="classField.html" title="something">Field</a> of type A to field of type F if the conversion is defined.  <br /></td></tr>
<tr class="separator:a995954d6f5b9afbb61c97d26ede30245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ced73338d6e65ef02e8666b77734f7"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; hila::is_assignable&lt; T &amp;, A &gt;::value||std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad5ced73338d6e65ef02e8666b77734f7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classField.html#ad5ced73338d6e65ef02e8666b77734f7">Field</a> (const A &amp;val)</td></tr>
<tr class="memdesc:ad5ced73338d6e65ef02e8666b77734f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classField.html" title="something">Field</a> object with scalar (val) of type A to a field of type F type if the conversion is defined.  <br /></td></tr>
<tr class="separator:ad5ced73338d6e65ef02e8666b77734f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6efe16047ac3c0e1085484fee66e36c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ac6efe16047ac3c0e1085484fee66e36c">Field</a> (const std::nullptr_t z)</td></tr>
<tr class="memdesc:ac6efe16047ac3c0e1085484fee66e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classField.html" title="something">Field</a> object with scalar 0 with nullpointer trick.  <br /></td></tr>
<tr class="separator:ac6efe16047ac3c0e1085484fee66e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c18c5ae7f65ac1c62b3b3404d41c3a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a7c18c5ae7f65ac1c62b3b3404d41c3a6">Field</a> (<a class="el" href="classField.html">Field</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a7c18c5ae7f65ac1c62b3b3404d41c3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classField.html" title="something">Field</a> object by stealing content from previous field (rhs) which will be set to null.  <br /></td></tr>
<tr class="separator:a7c18c5ae7f65ac1c62b3b3404d41c3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d9d8c48d69b16572cd59b3665a087a"><td class="memItemLeft" align="right" valign="top"><a id="a90d9d8c48d69b16572cd59b3665a087a" name="a90d9d8c48d69b16572cd59b3665a087a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> ()</td></tr>
<tr class="memdesc:a90d9d8c48d69b16572cd59b3665a087a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up memory for field content and communication. <br /></td></tr>
<tr class="separator:a90d9d8c48d69b16572cd59b3665a087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701808b5751abf7067322af0374a350c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a701808b5751abf7067322af0374a350c">free</a> ()</td></tr>
<tr class="memdesc:a701808b5751abf7067322af0374a350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys field data.  <br /></td></tr>
<tr class="separator:a701808b5751abf7067322af0374a350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd27a065b6419d6cb20b83ff3a3e56a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#aabd27a065b6419d6cb20b83ff3a3e56a">is_allocated</a> () const</td></tr>
<tr class="memdesc:aabd27a065b6419d6cb20b83ff3a3e56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classField.html" title="something">Field</a> data has been allocated.  <br /></td></tr>
<tr class="separator:aabd27a065b6419d6cb20b83ff3a3e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5766687a08277255d9496f4884e792a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a5766687a08277255d9496f4884e792a7">is_initialized</a> (Parity p) const</td></tr>
<tr class="memdesc:a5766687a08277255d9496f4884e792a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classField.html" title="something">Field</a> has been written.  <br /></td></tr>
<tr class="separator:a5766687a08277255d9496f4884e792a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3c6ec5d1f79839d38fb1eec7c4c536"><td class="memItemLeft" align="right" valign="top">gather_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#abb3c6ec5d1f79839d38fb1eec7c4c536">gather_status</a> (Parity p, int d) const</td></tr>
<tr class="memdesc:abb3c6ec5d1f79839d38fb1eec7c4c536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current gather_status_t.  <br /></td></tr>
<tr class="separator:abb3c6ec5d1f79839d38fb1eec7c4c536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b73a0d1ca55fb875e39558c721cc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ab5b73a0d1ca55fb875e39558c721cc81">check_alloc</a> ()</td></tr>
<tr class="memdesc:ab5b73a0d1ca55fb875e39558c721cc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <a class="el" href="classField.html" title="something">Field</a> if it is not already allocated.  <br /></td></tr>
<tr class="separator:ab5b73a0d1ca55fb875e39558c721cc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b47d5fd4285b4d0ec0792eabfc6d5d"><td class="memItemLeft" align="right" valign="top"><a id="ac2b47d5fd4285b4d0ec0792eabfc6d5d" name="ac2b47d5fd4285b4d0ec0792eabfc6d5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_alloc</b> () const</td></tr>
<tr class="memdesc:ac2b47d5fd4285b4d0ec0792eabfc6d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classField.html" title="something">Field</a> is const assert that the <a class="el" href="classField.html" title="something">Field</a> is allocated. <br /></td></tr>
<tr class="separator:ac2b47d5fd4285b4d0ec0792eabfc6d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23333e84caea23096552c81d4d14228f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a23333e84caea23096552c81d4d14228f">mark_changed</a> (const Parity p) const</td></tr>
<tr class="memdesc:a23333e84caea23096552c81d4d14228f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bookkeeping for field communication.  <br /></td></tr>
<tr class="separator:a23333e84caea23096552c81d4d14228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6284838229f7f16695a53b4f6614b09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a6284838229f7f16695a53b4f6614b09e">mark_gathered</a> (int dir, const Parity p) const</td></tr>
<tr class="memdesc:a6284838229f7f16695a53b4f6614b09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the <a class="el" href="classField.html" title="something">Field</a> already gathered, no need to communicate.  <br /></td></tr>
<tr class="separator:a6284838229f7f16695a53b4f6614b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a7603d2c586f8d9f750fa033f86330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#ae2a7603d2c586f8d9f750fa033f86330">is_gathered</a> (int dir, Parity par) const</td></tr>
<tr class="memdesc:ae2a7603d2c586f8d9f750fa033f86330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the field has been gathered since the previous communication.  <br /></td></tr>
<tr class="separator:ae2a7603d2c586f8d9f750fa033f86330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef3528d25dda53c9da36b0a4e3a6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#abaef3528d25dda53c9da36b0a4e3a6ca">mark_gather_started</a> (int dir, Parity p) const</td></tr>
<tr class="memdesc:abaef3528d25dda53c9da36b0a4e3a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark communication has started.  <br /></td></tr>
<tr class="separator:abaef3528d25dda53c9da36b0a4e3a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf039c5421f877e1ed7c95ff361fc7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#adbf039c5421f877e1ed7c95ff361fc7b">is_gather_started</a> (int dir, Parity par) const</td></tr>
<tr class="memdesc:adbf039c5421f877e1ed7c95ff361fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if communication has started.  <br /></td></tr>
<tr class="separator:adbf039c5421f877e1ed7c95ff361fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060ef9db979e95d8477ffa2437289272"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a060ef9db979e95d8477ffa2437289272">boundary_need_to_communicate</a> (const Direction dir) const</td></tr>
<tr class="separator:a060ef9db979e95d8477ffa2437289272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2344d33fe247023dd759e2d232a5d04e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a2344d33fe247023dd759e2d232a5d04e">set_boundary_condition</a> (Direction dir, <a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">hila::bc</a> bc)</td></tr>
<tr class="memdesc:a2344d33fe247023dd759e2d232a5d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the boundary condition in a given Direction (periodic or antiperiodic)  <br /></td></tr>
<tr class="separator:a2344d33fe247023dd759e2d232a5d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e40eed1d9107a489224206282bb179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">hila::bc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a38e40eed1d9107a489224206282bb179">get_boundary_condition</a> (Direction dir) const</td></tr>
<tr class="memdesc:a38e40eed1d9107a489224206282bb179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boundary condition of the <a class="el" href="classField.html" title="something">Field</a>.  <br /></td></tr>
<tr class="separator:a38e40eed1d9107a489224206282bb179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16c8dfd440b738952c86465f2a53bec"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ab16c8dfd440b738952c86465f2a53bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classField.html#ab16c8dfd440b738952c86465f2a53bec">copy_boundary_condition</a> (const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab16c8dfd440b738952c86465f2a53bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the boundary condition from another field.  <br /></td></tr>
<tr class="separator:ab16c8dfd440b738952c86465f2a53bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6206388d8c609b6a22dd2379fed258c6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a6206388d8c609b6a22dd2379fed258c6">get_value_at</a> (const unsigned i) const</td></tr>
<tr class="separator:a6206388d8c609b6a22dd2379fed258c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e46f9db917092b26a09fe72dc625892"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a6e46f9db917092b26a09fe72dc625892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classField.html#a6e46f9db917092b26a09fe72dc625892">set_value_at</a> (const A &amp;value, unsigned i)</td></tr>
<tr class="separator:a6e46f9db917092b26a09fe72dc625892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Standard arithmetic ops which fields should implement Not all are always callable, e.g. division may not be implemented by all field types</p>
<p>Standard arithmetic ops which fields should implement Not all are always callable, e.g. division may not be implemented by all field types </p>
</div></td></tr>
<tr class="memitem:a0524b7e483fa9fdd178f71c7981c6771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a0524b7e483fa9fdd178f71c7981c6771">operator=</a> (const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0524b7e483fa9fdd178f71c7981c6771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic assignment operator.  <br /></td></tr>
<tr class="separator:a0524b7e483fa9fdd178f71c7981c6771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift operations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Create a periodically shifted copy of the field</p>
<p>this is currently OK only for short moves, very inefficient for longer moves </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>/ /** </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>make more advanced, switching to "global" move for long shifts </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td></td></tr>
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;&amp; returns a reference to res </dd></dl>
</div></td></tr>
<tr class="memitem:aecd390783ab59a1d36902e794f6d0641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#aecd390783ab59a1d36902e794f6d0641">shift</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;v, <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;r) const</td></tr>
<tr class="separator:aecd390783ab59a1d36902e794f6d0641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a40a58d44e5b87e4189bf3242b79a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classField.html#a8a40a58d44e5b87e4189bf3242b79a32">shift</a> (const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;v, Parity par) const</td></tr>
<tr class="separator:a8a40a58d44e5b87e4189bf3242b79a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9f12ebc3ba5eeb4c781c484e244e3a55"><td class="memItemLeft" align="right" valign="top"><a id="a9f12ebc3ba5eeb4c781c484e244e3a55" name="a9f12ebc3ba5eeb4c781c484e244e3a55"></a>
<a class="el" href="classfield__struct.html">field_struct</a> *RESTRICT&#160;</td><td class="memItemRight" valign="bottom"><b>fs</b></td></tr>
<tr class="memdesc:a9f12ebc3ba5eeb4c781c484e244e3a55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classField.html#a9f12ebc3ba5eeb4c781c484e244e3a55" title="Field::fs keeps all of the field content.">Field::fs</a> keeps all of the field content. <br /></td></tr>
<tr class="separator:a9f12ebc3ba5eeb4c781c484e244e3a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class Field&lt; T &gt;</div><p>something </p>
<p>The field class implements the standard methods for accessing fields Hilapp replaces the parity access patterns, <a class="el" href="classField.html" title="something">Field</a>[par] with a loop over the appropriate sites.</p>
<p>The <a class="el" href="classField.html" title="something">Field</a> class also contains member functions used by hilapp, as well as members that may be useful for application developers.</p>
<p>The <a class="el" href="classField.html" title="something">Field</a> mainly implements the interface to the <a class="el" href="classField.html" title="something">Field</a> and not the content.</p>
<p>The <a class="el" href="classField.html" title="something">Field</a> contains a pointer to Field::field_struct, which implements MPI communication of the <a class="el" href="classField.html" title="something">Field</a> boundaries.</p>
<p>The Field::field_struct points to a <a class="el" href="classfield__storage.html" title="The field_storage struct contains minimal information for using the field in a loop....">field_storage</a>, which is defined by each backend. It implements storing and accessing the <a class="el" href="classField.html" title="something">Field</a> data, including buffers for storing haloes returned from MPI communication. Field.set_elements(): set elements in the <a class="el" href="classField.html" title="something">Field</a> <a class="el" href="classField.html#abd01a2a3e8b22665b12767bbc1d4a3b6" title="Set a single element. Assuming that each node calls this with the same value, it is sufficient to set...">Field.set_element()</a>: set an element in the <a class="el" href="classField.html" title="something">Field</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>double, complex </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00061">61</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a05c4ad5e101c1d79a90f8a9d92e0069b" name="a05c4ad5e101c1d79a90f8a9d92e0069b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c4ad5e101c1d79a90f8a9d92e0069b">&#9670;&#160;</a></span>Field() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a new <a class="el" href="classField.html" title="something">Field</a> object. </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00209">209</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a522b40a16a45ee82cc0e4f22e5bf8bb3" name="a522b40a16a45ee82cc0e4f22e5bf8bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522b40a16a45ee82cc0e4f22e5bf8bb3">&#9670;&#160;</a></span>Field() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with already initialised <a class="el" href="classField.html" title="something">Field</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00229">229</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a995954d6f5b9afbb61c97d26ede30245" name="a995954d6f5b9afbb61c97d26ede30245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995954d6f5b9afbb61c97d26ede30245">&#9670;&#160;</a></span>Field() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor form <a class="el" href="classField.html" title="something">Field</a> of type A to field of type F if the conversion is defined. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00241">241</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ad5ced73338d6e65ef02e8666b77734f7" name="ad5ced73338d6e65ef02e8666b77734f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ced73338d6e65ef02e8666b77734f7">&#9670;&#160;</a></span>Field() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; hila::is_assignable&lt; T &amp;, A &gt;::value||std::is_convertible&lt; A, T &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classField.html" title="something">Field</a> object with scalar (val) of type A to a field of type F type if the conversion is defined. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00256">256</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ac6efe16047ac3c0e1085484fee66e36c" name="ac6efe16047ac3c0e1085484fee66e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6efe16047ac3c0e1085484fee66e36c">&#9670;&#160;</a></span>Field() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classField.html" title="something">Field</a> object with scalar 0 with nullpointer trick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00264">264</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a7c18c5ae7f65ac1c62b3b3404d41c3a6" name="a7c18c5ae7f65ac1c62b3b3404d41c3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c18c5ae7f65ac1c62b3b3404d41c3a6">&#9670;&#160;</a></span>Field() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt;<a class="el" href="classField.html">::Field</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classField.html" title="something">Field</a> object by stealing content from previous field (rhs) which will be set to null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00274">274</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a060ef9db979e95d8477ffa2437289272" name="a060ef9db979e95d8477ffa2437289272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060ef9db979e95d8477ffa2437289272">&#9670;&#160;</a></span>boundary_need_to_communicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classField.html">Field</a>&lt; T &gt;::boundary_need_to_communicate </td>
          <td>(</td>
          <td class="paramtype">const Direction&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>function boundary_need_to_communicate(dir) returns false if there's special B.C. which does not need comms here, otherwise true </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00496">496</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ab5b73a0d1ca55fb875e39558c721cc81" name="ab5b73a0d1ca55fb875e39558c721cc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b73a0d1ca55fb875e39558c721cc81">&#9670;&#160;</a></span>check_alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::check_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <a class="el" href="classField.html" title="something">Field</a> if it is not already allocated. </p>
<p>check that <a class="el" href="classField.html" title="something">Field</a> is allocated, and if not do it (if not const) Must be called BEFORE the var is actually used "hilapp" will generate these calls as needed! </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00396">396</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ab16c8dfd440b738952c86465f2a53bec" name="ab16c8dfd440b738952c86465f2a53bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16c8dfd440b738952c86465f2a53bec">&#9670;&#160;</a></span>copy_boundary_condition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::copy_boundary_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a>&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the boundary condition from another field. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>the type of the field which we are copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the ohter <a class="el" href="classField.html" title="something">Field</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00583">583</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a48de521e9e9beb5907351e7ee8721b0e" name="a48de521e9e9beb5907351e7ee8721b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48de521e9e9beb5907351e7ee8721b0e">&#9670;&#160;</a></span>copy_local_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::copy_local_data </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the local (mpi process) data to a "logical array" on gpu code, copies to host </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00718">718</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="abeefcc169a728e8ead3e13961926e689" name="abeefcc169a728e8ead3e13961926e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeefcc169a728e8ead3e13961926e689">&#9670;&#160;</a></span>drop_comms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::drop_comms </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classField.html#abeefcc169a728e8ead3e13961926e689">drop_comms()</a>: if field is changed or deleted, cancel ongoing communications. This should happen very seldom, only if there are "by-hand" start_gather operations and these are not needed </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l01476">1476</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ac3d7d4e07765a8511ee7ea0922e35998" name="ac3d7d4e07765a8511ee7ea0922e35998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d7d4e07765a8511ee7ea0922e35998">&#9670;&#160;</a></span>FFT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::FFT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fft_direction&#160;</td>
          <td class="paramname"><em>fftdir</em> = <code>fft_direction::forward</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classField.html" title="something">Field</a> method for performing FFT res = a.FFT(); fftdir: fft_direction::forward (default) or fft_direction::back </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00421">421</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="ab6d7704bd2de4fdfff86808f7cb27f04" name="ab6d7704bd2de4fdfff86808f7cb27f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d7704bd2de4fdfff86808f7cb27f04">&#9670;&#160;</a></span>FFT_real_to_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; <a class="el" href="classComplex.html">Complex</a>&lt; hila::scalar_type&lt; T &gt; &gt; &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::FFT_real_to_complex </td>
          <td>(</td>
          <td class="paramtype">fft_direction&#160;</td>
          <td class="paramname"><em>fftdir</em> = <code>fft_direction::forward</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>FFT_real_to_complex: <a class="el" href="classField.html" title="something">Field</a> must be a real-valued field, result is a complex-valued field of the same type Implemented just by doing a FFT with a complex field with im=0; fft_direction::back gives a complex conjugate of the forward transform Result is f(-x) = f(L - x) = f(x)^* </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00445">445</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="a701808b5751abf7067322af0374a350c" name="a701808b5751abf7067322af0374a350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701808b5751abf7067322af0374a350c">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys field data. </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00338">338</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="abb3c6ec5d1f79839d38fb1eec7c4c536" name="abb3c6ec5d1f79839d38fb1eec7c4c536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3c6ec5d1f79839d38fb1eec7c4c536">&#9670;&#160;</a></span>gather_status()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gather_status_t <a class="el" href="classField.html">Field</a>&lt; T &gt;::gather_status </td>
          <td>(</td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns current gather_status_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="classField.html" title="something">Field</a> partiy </td></tr>
    <tr><td class="paramname">d</td><td>Direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gather_status_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00380">380</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a38e40eed1d9107a489224206282bb179" name="a38e40eed1d9107a489224206282bb179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e40eed1d9107a489224206282bb179">&#9670;&#160;</a></span>get_boundary_condition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">hila::bc</a> <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_boundary_condition </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the boundary condition of the <a class="el" href="classField.html" title="something">Field</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Boundary condition in certain direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805" title="list of field boundary conditions - used only if SPECIAL_BOUNDARY_CONDITIONS defined">hila::bc</a> The boundary condition of the <a class="el" href="classField.html" title="something">Field</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00559">559</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a33f905efa61f6af54664845f72430d69" name="a33f905efa61f6af54664845f72430d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f905efa61f6af54664845f72430d69">&#9670;&#160;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get singular element which will be broadcast to all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>coordinate of which the element is fetched with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00879">879</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ae62500759ad146835236688bfca45354" name="ae62500759ad146835236688bfca45354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62500759ad146835236688bfca45354">&#9670;&#160;</a></span>get_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_elements </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves list of elements to all nodes. </p>
<p>Get a list of elements and store them into a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord_list</td><td>vector of coordinates which will be fetched </td></tr>
    <tr><td class="paramname">broadcast</td><td>if true then elements retrieved to root node will be broadcast to all nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;T&gt; list of all elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00662">662</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="a6206388d8c609b6a22dd2379fed258c6" name="a6206388d8c609b6a22dd2379fed258c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6206388d8c609b6a22dd2379fed258c6">&#9670;&#160;</a></span>get_value_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classField.html">Field</a>&lt; T &gt;::get_value_at </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an individual element outside a loop. This is also used as a getter in the vanilla code. </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00611">611</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="aabd27a065b6419d6cb20b83ff3a3e56a" name="aabd27a065b6419d6cb20b83ff3a3e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd27a065b6419d6cb20b83ff3a3e56a">&#9670;&#160;</a></span>is_allocated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classField.html">Field</a>&lt; T &gt;::is_allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classField.html" title="something">Field</a> data has been allocated. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Cpp {};</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00359">359</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="adbf039c5421f877e1ed7c95ff361fc7b" name="adbf039c5421f877e1ed7c95ff361fc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf039c5421f877e1ed7c95ff361fc7b">&#9670;&#160;</a></span>is_gather_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classField.html">Field</a>&lt; T &gt;::is_gather_started </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if communication has started. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is method is generally used only by the HILA pre-processor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td></td></tr>
    <tr><td class="paramname">par</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00485">485</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ae2a7603d2c586f8d9f750fa033f86330" name="ae2a7603d2c586f8d9f750fa033f86330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a7603d2c586f8d9f750fa033f86330">&#9670;&#160;</a></span>is_gathered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classField.html">Field</a>&lt; T &gt;::is_gathered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the field has been gathered since the previous communication. </p>
<p>par = ALL: ALL or (EVEN+ODD) are OK<br  />
 par != ALL: ALL or par are OK </p><dl class="section remark"><dt>Remarks</dt><dd>This is method is generally used only by the HILA pre-processor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td></td></tr>
    <tr><td class="paramname">par</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00457">457</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a5766687a08277255d9496f4884e792a7" name="a5766687a08277255d9496f4884e792a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5766687a08277255d9496f4884e792a7">&#9670;&#160;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classField.html">Field</a>&lt; T &gt;::is_initialized </td>
          <td>(</td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classField.html" title="something">Field</a> has been written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="classField.html" title="something">Field</a> parity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00369">369</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a23333e84caea23096552c81d4d14228f" name="a23333e84caea23096552c81d4d14228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23333e84caea23096552c81d4d14228f">&#9670;&#160;</a></span>mark_changed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::mark_changed </td>
          <td>(</td>
          <td class="paramtype">const Parity&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bookkeeping for field communication. </p>
<p>If ALL changes, both parities invalid; if p != ALL, then p and ALL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="classField.html" title="something">Field</a> parity </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00414">414</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="abaef3528d25dda53c9da36b0a4e3a6ca" name="abaef3528d25dda53c9da36b0a4e3a6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaef3528d25dda53c9da36b0a4e3a6ca">&#9670;&#160;</a></span>mark_gather_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::mark_gather_started </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark communication has started. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is method is generally used only by the HILA pre-processor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td></td></tr>
    <tr><td class="paramname">p</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00474">474</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a6284838229f7f16695a53b4f6614b09e" name="a6284838229f7f16695a53b4f6614b09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6284838229f7f16695a53b4f6614b09e">&#9670;&#160;</a></span>mark_gathered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::mark_gathered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the <a class="el" href="classField.html" title="something">Field</a> already gathered, no need to communicate. </p>
<p>Mark the field parity gathered from Direction In case p=ALL we could mark everything gathered, but we'll be conservative here and mark only this parity, because there might be other parities on the fly and corresponding waits should be done, This should never happen in automatically generated loops. In any case start_gather, is_gathered, get_gather_parity has intelligence to figure out the right thing to do</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td></td></tr>
    <tr><td class="paramname">p</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00443">443</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a0524b7e483fa9fdd178f71c7981c6771" name="a0524b7e483fa9fdd178f71c7981c6771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0524b7e483fa9fdd178f71c7981c6771">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp; <a class="el" href="classField.html">Field</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;&amp; </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00666">666</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a063e9cfeedb8a782e6d7461794db856e" name="a063e9cfeedb8a782e6d7461794db856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063e9cfeedb8a782e6d7461794db856e">&#9670;&#160;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::reflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dirs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field&lt;T&gt;::reflect() reflects the field around the desired axis This is here because it uses similar communications as fft TODO: refactorise so that there is separate "make columns" class! </p>

<p class="definition">Definition at line <a class="el" href="fft_8h_source.html#l00539">539</a> of file <a class="el" href="fft_8h_source.html">fft.h</a>.</p>

</div>
</div>
<a id="a2344d33fe247023dd759e2d232a5d04e" name="a2344d33fe247023dd759e2d232a5d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2344d33fe247023dd759e2d232a5d04e">&#9670;&#160;</a></span>set_boundary_condition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::set_boundary_condition </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehila.html#a81cf9e19b8543be54f6afc7d2bd17805">hila::bc</a>&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the boundary condition in a given Direction (periodic or antiperiodic) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Direction of boundary condition </td></tr>
    <tr><td class="paramname">bc</td><td><a class="el" href="classField.html" title="something">Field</a> boundary condition </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00513">513</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a6e46f9db917092b26a09fe72dc625892" name="a6e46f9db917092b26a09fe72dc625892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e46f9db917092b26a09fe72dc625892">&#9670;&#160;</a></span>set_value_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::set_value_at </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an individual element outside a loop. This is also used as a setter in the vanilla code. </p>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00631">631</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="aecd390783ab59a1d36902e794f6d0641" name="aecd390783ab59a1d36902e794f6d0641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd390783ab59a1d36902e794f6d0641">&#9670;&#160;</a></span>shift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp; <a class="el" href="classField.html">Field</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section remark"><dt>Remarks</dt><dd>Overload of shift(const CoordinateVector &amp;v, Field&lt;T&gt; &amp;r, Parity par) with par=ALL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l00845">845</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="a8a40a58d44e5b87e4189bf3242b79a32" name="a8a40a58d44e5b87e4189bf3242b79a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a40a58d44e5b87e4189bf3242b79a32">&#9670;&#160;</a></span>shift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>&lt; T &gt; <a class="el" href="classField.html">Field</a>&lt; T &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Field&lt;T&gt;</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Add remark in comparison to other version of shift </dd></dl>

<p class="definition">Definition at line <a class="el" href="field_8h_source.html#l01465">1465</a> of file <a class="el" href="field_8h_source.html">field.h</a>.</p>

</div>
</div>
<a id="ac76a0477380e02532746853d16983c4a" name="ac76a0477380e02532746853d16983c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76a0477380e02532746853d16983c4a">&#9670;&#160;</a></span>start_gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">dir_mask_t <a class="el" href="classField.html">Field</a>&lt; T &gt;::start_gather </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em> = <code>ALL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Communication routines. </p>
<p><a class="el" href="classField.html#ac76a0477380e02532746853d16983c4a" title="Communication routines.">start_gather()</a>: Communicate the field at Parity par from Direction d. Uses accessors to prevent dependency on the layout. return the Direction mask bits where something is happening </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00262">262</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="ab039d34f2e65c9cd58326fd013efd90c" name="ab039d34f2e65c9cd58326fd013efd90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab039d34f2e65c9cd58326fd013efd90c">&#9670;&#160;</a></span>wait_gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::wait_gather </td>
          <td>(</td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parity&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classField.html#ab039d34f2e65c9cd58326fd013efd90c">wait_gather()</a>: Wait for communication at parity par from Direction d completes the communication in the function. If the communication has not started yet, also calls <a class="el" href="classField.html#ac76a0477380e02532746853d16983c4a" title="Communication routines.">start_gather()</a></p>
<p>NOTE: This will be called even if the field is marked const. Therefore this function is const, even though it does change the internal content of the field, the halo. From the point of view of the user, the value of the field does not change. </p>

<p class="definition">Definition at line <a class="el" href="field__comm_8h_source.html#l00394">394</a> of file <a class="el" href="field__comm_8h_source.html">field_comm.h</a>.</p>

</div>
</div>
<a id="a2e5c03dc76de38ba2c953edf1e8ebb7b" name="a2e5c03dc76de38ba2c953edf1e8ebb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5c03dc76de38ba2c953edf1e8ebb7b">&#9670;&#160;</a></span>write_subvolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classField.html">Field</a>&lt; T &gt;::write_subvolume </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>outputfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCoordinateVector__t.html">CoordinateVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a "subspace" of the original lattice Each element is written on a single line TODO: more formatting? </p>

<p class="definition">Definition at line <a class="el" href="field__io_8h_source.html#l00215">215</a> of file <a class="el" href="field__io_8h_source.html">field_io.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="field_8h_source.html">field.h</a></li>
<li><a class="el" href="gpu__reduction_8h_source.html">gpu_reduction.h</a></li>
<li><a class="el" href="fft_8h_source.html">fft.h</a></li>
<li><a class="el" href="field__comm_8h_source.html">field_comm.h</a></li>
<li><a class="el" href="field__io_8h_source.html">field_io.h</a></li>
<li><a class="el" href="reduction_8h_source.html">reduction.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classField.html">Field</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HILA: User guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HILA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_guide_mainpage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Hila framework consists of</p>
<ol type="1">
<li>the hilapp and</li>
<li>a lattice simulation library.</li>
</ol>
<p>Transformer contains a C++ preprocessing tool and framework for programming lattice field theory simulations: the main method for getting measurements from non-perturbative quantum field theories. <br  />
</p>
<p>Lattice field theory simulations involve up to 4 dimensional grids whose points are updated continuously according to some Monte Carlo update algorithm. The update at each grid point depends on the data stored at neighboring lattice points, and the ideal update order depends on the parity of the lattice points. Efficient parallel implementations using MPI and GPU's can be quite complicated to implement, modify and debug. Some kind of simplification was clearly needed.</p>
<p>Transformer aims to make it easier for researchers to implement a broad class of these simulations by abstracting a lot of the technicalities involved, and by bringing the syntax from CUDA kernels and MPI calls to the essentials. The approach given here involves new datatypes and a preprocessing tool that converts c++ code with the new simplified syntax for loops and element accessors into working c++ code and gpu kernels.</p>
<p>Essentially, HilaPP extends C++ with statements of the following type: </p><div class="fragment"><div class="line">Field&lt;double&gt; f;</div>
<div class="line">f[ALL] = 1;</div>
<div class="line">f[EVEN] = f[X] + f[X+TUP];</div>
</div><!-- fragment --><p> The two latter statements are expanded into loops over all lattice sites and over EVEN sites, respectively. The ordering of sites in the loop is undefined.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
HilaPP</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
Generating this documentation</h2>
<p>Build the documentation (with the git hash as the version number) using </p><div class="fragment"><div class="line">PROJECT_NUMBER=$(git rev-parse --short HEAD) doxygen</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Compiling the HilaPP and using it on c++ code</h2>
<p>In short, the framework can be used in these steps:</p>
<ol type="1">
<li>Write c++ code using the syntax and datatypes laid out below</li>
<li>Use the hilapp excecutable to convert this code into .cpt code</li>
<li>Compile the new .cpt code into the final excecutable</li>
</ol>
<p><a class="anchor" id="imgDef"></a><img src="workflowV1.png" alt="imgDef" title="Workflow illustration" class="inline"/></p>
<p>To compile the hilapp, first create a build directory inside the main directory if it doesn't exist. Then, compile the hilapp by typing <code>make</code> in the main folder. This will create an executable called <code>hilapp</code> in the build folder.</p>
<p>You can then use it to compile an extended C++ file into standard C++ using </p><div class="fragment"><div class="line">bin/hilapp path/to/program.cpp</div>
</div><!-- fragment --><p> This will create a <code>cpt</code> file written in standard C++.</p>
<p>The <code>cpt</code> can be compiled with any c++ compiler, but must be linked against the headers and c++ files in the plumbing directory.</p>
<p>Check the example programs in the programs folder. You can use almost any standard C++ code, by there are a couple of new reserved names: the variable <code>X</code> and the function <code>onsites()</code>. In addition the framework defines a global <code>lattice</code> variable, which you should not overwrite.</p>
<p>In order to use the additional features for field type variables, you should inlude <code><a class="el" href="field_8h.html">plumbing/field.h</a></code> in you program. You can also include one or more of the files in the <code>datatypes</code> folder, which contains predefined datatypes that can be used to construct a field.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Using the Makefile system</h2>
<p>Each of the example applications has a makefile for compiling the application with a given target backend. To compile it, run </p><div class="fragment"><div class="line">make TARGET=target program_name</div>
</div><!-- fragment --><p> The lower case target should be replaced by one of <code>vanilla</code>, <code>AVX</code> or <code>CUDA</code>. This will create a <code>build</code> directory and compile the application there.</p>
<p>An application makefile should define any target files and include the main makefile. Here is an example with comments: </p><div class="fragment"><div class="line"># Give the location of the top level distribution directory wrt. this.</div>
<div class="line"># Can be absolute or relative</div>
<div class="line">TOP_DIR := ../..</div>
<div class="line"> </div>
<div class="line"># Add an application specific header to the dependencies</div>
<div class="line">APP_HEADERS := application.h</div>
<div class="line"> </div>
<div class="line"># Read in the main makefile contents, incl. platforms</div>
<div class="line">include $(TOP_DIR)/libraries/main.mk</div>
<div class="line"> </div>
<div class="line"># With multiple targets we want to use &quot;make target&quot;, not &quot;make build/target&quot;.</div>
<div class="line"># This is needed to carry the dependencies to build-subdir</div>
<div class="line">application: build/application ; @:</div>
<div class="line"> </div>
<div class="line"># Now the linking step for each target executable</div>
<div class="line">build/application: Makefile build/application.o $(HILA_OBJECTS) $(HEADERS) </div>
<div class="line">    $(LD) -o $@ build/application.o $(HILA_OBJECTS) $(LDFLAGS) $(LDLIBS)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Compiling on Puhti</h3>
<p>There is a separate makefile for compiling hilapp on Puhti. To use it, run </p><div class="fragment"><div class="line">module load gcc</div>
<div class="line">make -f Makefile_puhti</div>
</div><!-- fragment --><p>This will link against the llvm installation in the hila development project folder.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Syntax - What works</h2>
<h3><a class="anchor" id="autotoc_md21"></a>
Single line statements</h3>
<p>You can operate on fields using statements like </p><div class="fragment"><div class="line">my_field[ALL] = my_other_field[X] + my_third_field[X];</div>
</div><!-- fragment --><p> On the left-hand side of the statement you should specify either <code>[ALL]</code> lattice sites, <code>[EVEN]</code> sites or <code>[ODD]</code> sites. The statement will apply only to this collection of sites. On the right hand side, use <code>[X]</code> to refer to this collection of sites.</p>
<p>You can refer to neighbouring sites by adding a Direction (<code>e_x</code>, <code>-e_x</code>, <code>e_y</code>, <code>-e_y</code>, <code>e_z</code>, <code>-e_z</code>, <code>e_t</code>, <code>-e_t</code>, ...): </p><div class="fragment"><div class="line">my_field[EVEN] = my_field[X+e_y];</div>
</div><!-- fragment --><p>You can also operate on fields directly, </p><div class="fragment"><div class="line">my_field = my_field + 1;</div>
</div><!-- fragment --><p> This will operate on all sites and is equivalent to </p><div class="fragment"><div class="line">my_field[ALL] = my_field[X] + 1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
General loops</h3>
<p>Loops over all sites or a parity: </p><div class="fragment"><div class="line">forsites(ALL){}</div>
<div class="line">forsites(EVEN){}</div>
<div class="line">forsites(ODD){}</div>
</div><!-- fragment --><p> Inside the loop, refer to the sites using X: </p><div class="fragment"><div class="line">forsites(ALL){</div>
<div class="line">    my_field[X] = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As before, you can refer to neighbouring sites by adding a Direction: </p><div class="fragment"><div class="line">forsites(EVEN){</div>
<div class="line">    my_field[X] = my_field[X+e_y];</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
What doesn't work (as expected)</h2>
<p>Functions that implicitly depend on the site and return a number. For example </p><div class="fragment"><div class="line">forsites(EVEN){</div>
<div class="line">    matrix_field[X].gaussian();</div>
<div class="line">}</div>
</div><!-- fragment --><p> runs incorrectly with AVX. It does not actually run once for each site, but only once for each vector.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Extensions</h1>
<h2><a class="anchor" id="autotoc_md25"></a>
HMC</h2>
<h3><a class="anchor" id="autotoc_md26"></a>
Gauge field</h3>
<p>The <a class="el" href="classgauge__field__base.html">gauge field</a> class is mainly a convenient wrapper containing a matrix field for each Direction. It allows us to refer to the gauge field as <code><a class="el" href="classgauge__field.html">gauge_field</a>&lt;SUN&gt; U</code> rather than <code>SUN U[NDIM]</code>, which is inconvenient to pass as a reference.</p>
<p>The <a class="el" href="classgauge__field__base.html">gauge fields</a> also contains a momentum field. Since fields are only allocated if necessary, this is not a large amount of data. <a class="el" href="classgauge__field.html">Fundamental gauge fields</a> can also store a copy of the gauge field for HMC.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Actions</h3>
<p><a class="el" href="classaction__base.html">Actions</a> represent terms in the full action of a quantum field theory and are used to set up the HMC simulation. Each <a class="el" href="classaction__base.html">action</a> implements at least</p>
<ol type="1">
<li><code>double action()</code>: returns the current value of the action</li>
<li><code>void force_step()</code>: calculates the derivative and updates canonical momenta</li>
<li><code>void draw_gaussian_fields()</code>: draws random values for any gaussian fields</li>
<li><code>void backup_fields()</code>: make a backup of gauge fields at the beginning of HMC</li>
<li><code>void restore_backup()</code>: restore the original field from the backup if the update is rejected</li>
</ol>
<p>For example, the <a class="el" href="classgauge__action.html">gauge action</a> represents the Wilson plaquette action </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_{gauge} = \sum_x \beta\left [ 1 - Re \sum_{\mu&gt;\nu} U_{x,\mu} U_{x+\mu,\nu} U^\dagger_{x+\nu, \mu} U^\dagger_{x,\nu} \right ] \]" src="form_0.png" width="274" height="40"/>
</p>
<p>The <a class="el" href="classfermion__action.html">fermion action</a> represents the pseudo fermion action </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_{fermion} = e^{-\sum_{x,y} \chi_x^\dagger \left(\frac{1}{D^\dagger D}\right)_{x,y} \chi_y}. \]" src="form_1.png" width="181" height="24"/>
</p>
<p> The Dirac operator can be any of the implemented <a class="el" href="classDirac__Wilson.html">Wilson Dirac</a> operator, the <a class="el" href="classDirac__Wilson__evenodd.html">even-odd preconditioned Wilson Dirac</a> operator, the <a class="el" href="classdirac__staggered.html">staggered Dirac</a> operator or the <a class="el" href="classdirac__staggered__evenodd.html">even-odd preconditioned staggered Dirac</a> operator. See operators below for more detail about how these and the matrix inversion are used.</p>
<p>At small mass it is often more efficient to split the fermion determinant </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z_{fermion} = \int d\chi e^{-S_{fermion}} = det\left( D^\dagger D \right) \]" src="form_2.png" width="220" height="29"/>
</p>
<p> to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ det\left( D^\dagger D \right) = det\left( (D + m)^\dagger (D + m) \right) det\left( \frac{ D^\dagger D }{(D + m)^\dagger (D + m)} \right) \]" src="form_3.png" width="340" height="33"/>
</p>
<p> To use this, you need two actions, <a class="el" href="classHasenbusch__action__1.html">Hasenbusch action 1</a> and <a class="el" href="classHasenbusch__action__2.html">Hasenbusch action 2</a>.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
Integrators</h3>
<p>An <a class="el" href="classintegrator__base.html">integrator</a> updates the gauge fields and their canonical momenta keeping the action approximately constant. Two integrators are defined, the <a class="el" href="classleapfrog__integrator.html">leapfrog</a> and the <a class="el" href="classO2__integrator.html">O2</a> (aka Omelyan) integrators.</p>
<p><a class="el" href="classintegrator__base.html">Integrators</a> are constructed from an action term and a lower level integrator (or the momentum action on the lowest level). An integrator step updates the gauge field keeping the action approximately constant.</p>
<p><a class="el" href="classintegrator__base.html">Integrators</a> form a hierarchy, where lowest levels are run more often in a trajectory. The momentum action is also an integrator and forms the lowest level. Generally the force of the gauge action is fast to calculate and should be added second. The fermion action is the most expensive due to the inversion of the Dirac matrix and should be added on a high level.</p>
<p>The <a class="el" href="classleapfrog__integrator.html">leapfrog</a> integrator requires a single evaluation of the derivative of the action term and conserves the action to second order in the step size. The <a class="el" href="classO2__integrator.html">O2</a> integrator conserves the action to the third order in the, but requires two evaluations.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Full HMC</h3>
<p>The full process of setting up HMC is </p><div class="fragment"><div class="line">// First define a gauge field</div>
<div class="line">gauge_field&lt;SU&lt;N, double&gt;&gt; gauge;</div>
<div class="line"> </div>
<div class="line">// Let&#39;s just start from unity</div>
<div class="line">gauge.set_unity();</div>
<div class="line"> </div>
<div class="line">// Set up the action of the gauge and momentum actions</div>
<div class="line">gauge_action ga(gauge, beta);</div>
<div class="line">gauge_momentum_action ma(gauge);</div>
<div class="line"> </div>
<div class="line">// Set up the first level in the intergator hierarchy</div>
<div class="line">O2_integrator integrator_level_1(ga, ma);</div>
<div class="line"> </div>
<div class="line">// Define the Dirac operator</div>
<div class="line">dirac_staggered_evenodd D(mass, gauge);</div>
<div class="line"> </div>
<div class="line">// and the fermion action</div>
<div class="line">fermion_action fa(D, gauge);</div>
<div class="line"> </div>
<div class="line">// and finally the second level of the integrator</div>
<div class="line">O2_integrator integrator_level_2(fsum, integrator_level_1);</div>
<div class="line"> </div>
<div class="line">// Now we can run an HMC trajectory</div>
<div class="line">update_hmc(integrator_level_2, hmc_steps, traj_length);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Operators</h2>
<p>Operators are classes that define an <code>apply(<a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; input, <a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; output)</code> method. The method takes the a field and runs a transformation on it, returning the result in the output field.</p>
<p>The <a class="el" href="classDirac__Wilson.html">Wilson Dirac</a> and <a class="el" href="classdirac__staggered.html">staggered Dirac</a> operators are defined in libraries/dirac. They implement the two most common lattice Dirac operators. These files also have the even-odd preconditioned versions of these operators.</p>
<p>The Dirac operators also have a <code>dagger(<a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; input, <a class="el" href="classField.html" title="something">Field</a>&lt;type&gt; output)</code> method, which implements the conjugate of the operator.</p>
<p>The <a class="el" href="classCG.html">conjugate gradient</a> operator calculates the inverse of the square of an operator applied to a vector </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ out = CG(D) in = \frac{1}{D^\dagger D} in. \]" src="form_4.png" width="146" height="26"/>
</p>
<p> In is defined in <a class="el" href="conjugate__gradient_8h_source.html">libraries/dirac/conjugate_gradient.h</a></p>
<p>Note that the <a class="el" href="classHasenbusch__operator.html">Hasenbusch preconditioned operator</a> in <a class="el" href="conjugate__gradient_8h_source.html">libraries/dirac/conjugate_gradient.h</a> is a utility class used in the Hasenbusch action.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Backends</h2>
<p>Backends are primarily implemented in three places. First, in HilaPP, loop generation and loop function handling code is in the files <code>hilapp/src/codegen_*.cpp</code>. The code generation functions are called in backend_handle_loop_function and backend_generate_code.</p>
<p>In order to define a new backend, you should edit the two functions above, implement the code generation function and add any new files to <code>hilapp/Makefile</code>.</p>
<p>Second, in the library in the folders <code>libraries/plumbing/backend_*</code>. These implement field storage in (usually in <code>field_storage_backend.h</code>), any other necessary top level definitions in <code>defs.h</code> and possible an extension of the lattice class in <code>lattice.h</code>. These are included in <code><a class="el" href="field__storage_8h.html">libraries/plumbing/field_storage.h</a></code>, <code><a class="el" href="defs_8h_source.html">libraries/plumbing/defs.h</a></code> and <code><a class="el" href="lattice_8h_source.html">libraries/plumbing/lattice.h</a></code> respectively.</p>
<p>A new backend should implement at least the field storage class. The new file needs to be included in <code><a class="el" href="field__storage_8h.html">libraries/plumbing/field_storage.h</a></code>.</p>
<p>Finally, <code>libraries/platforms</code> has a collection of makefiles, chosen by the <code>ARCH</code> flag in the standard Makefile. These include combinations of a specific system and a backend. New backend requires a new makefile that defines the necessary flags to produce and compile the correct code.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Testing</h1>
<p>In the <code>programs/test_cases</code> folder you can find a collection of simple test programs. To test whether the translations work on the cpu, type:</p>
<div class="fragment"><div class="line">./test.sh </div>
</div><!-- fragment --><p>This tests the transform, compilation and run process for the test_*.cpp files for dimensions from 1 to 4, and outputs the exit status of each step. If you're on a machine with GPU's, you can test the GPU transformations with:</p>
<div class="fragment"><div class="line">./test_GPU.sh</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
OLD HILA README</h1>
<h2><a class="anchor" id="autotoc_md34"></a>
Datatypes</h2>
<ul>
<li>NDIM: number of dimensions, values 2,3,4 (TODO: NDIM=1?). Typically set in application Makefile</li>
<li>Standard types: <code>int</code>, <code>int64_t</code>, <code>float</code>, <code>double</code> (<code>long double</code>?)</li>
<li><p class="startli">Hila provided basic types: <code><a class="el" href="classComplex.html">Complex</a>\&lt;S\&gt;</code>, <code>Vector\&lt;n,T\&gt;</code>, <code><a class="el" href="classMatrix.html" title="Generic Matrix class fwd definition.">Matrix</a>\&lt;n,m,T\&gt;</code>, <code>SquareMatrix\&lt;n,T\&gt;</code>, <code><a class="el" href="classArray.html" title="nxm Array type">Array</a>\&lt;n,m,T\&gt;</code></p>
<p class="startli">Here S is any standard type, and T includes S and <a class="el" href="classComplex.html">Complex</a>&lt;S&gt;. C++ or C standard complex types should not be used (not AVX vectorizable). See docs for functions/methods (TODO Doxygen docs)</p>
</li>
<li>Special types:<ul>
<li><code>Parity</code>: enum with values EVEN, ODD, ALL; refers to parity of the site. Parity of site (x,y,z,t) is even if <code>(x+y+z+t)</code> is even, odd otherwise.</li>
<li><code>Direction</code>: conceptually unit vector with values <code>±e_x, ±e_y, ±e_z, ±e_t</code> (if NDIM==4). Implemented as an enum class. Can be used to index arrays of size NDIM.</li>
<li><p class="startli"><code>CoordinateVector</code>: derived from Vector&lt;NDIM,int&gt;.</p>
<p class="startli">Direction variable acts as an unit vector in vector algebra: (assume below NDIM=4)</p>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">CoordinateVector v;</div>
<div class="line">Direction d = e_x;</div>
<div class="line">v = d;             // v = [1,0,0,0]</div>
<div class="line">v += e_y - 3*d;    // v = [-2,1,0,0]</div>
<div class="line">v = {0,1,-1,0};    // v = [0,1,-1,0] equivalent v = e_y - e_z;</div>
<div class="line">hila::out0 &lt;&lt; v.dot({1,2,3,4});  // dot product of 2 vectors, prints -1</div>
<div class="line">int j = d;         // ok</div>
<div class="line">d = j;             // ERROR: cannot assign int to Direction</div>
<div class="line">++d;               // e_x -&gt; e_y</div>
<div class="line">is_up_dir(d);      // true if d is along positive x,y,z,t -dir.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Field access and traversal</h2>
<p>The principal traversal of the lattice is with <em>site loops</em> <code>onsites(Parity)</code>, and a special location identifier <code>X</code> (effectively a new keyword). <br  />
</p>
<div class="fragment"><div class="line">using mytype = Matrix&lt;3,3,Complex&lt;double&gt;&gt;;   // use type alias</div>
<div class="line">Field&lt;mytype&gt; f,g,h;</div>
<div class="line">. . .</div>
<div class="line"> </div>
<div class="line">onsites(ALL) f[X] = 2 + g[X];          // 2 acts as 2*I for square matrices</div>
<div class="line">f[ALL] = 2 + g[X];                     // equivalent shorter form for simple 1-line assignments</div>
<div class="line">f = 2 + g;                             // this is also equivalent!</div>
<div class="line"> </div>
<div class="line">parity p = EVEN;</div>
<div class="line">Direction d = e_x;</div>
<div class="line"> </div>
<div class="line">onsites(p) {</div>
<div class="line">    auto t = g[X + d];                 // X +- Direction fetches from neighbour site</div>
<div class="line">    f[X] += t + t*t;                   // can define variables in the loop   </div>
<div class="line"> </div>
<div class="line">    h[X] = g[X + e_x - 2*e_y];         // non-nearest neighbour fetch (TODO:optimize!)</div>
<div class="line"> </div>
<div class="line">    if (X.coordinate(e_t) == 0) {      // Do this on 1st timeslice only</div>
<div class="line">         h[X] *= 0.5;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>X</code> can be used only inside site loops. <br  />
 Access operation <code>f[X]</code> can be applied only to field variables, and has the type of the field element (in the case above <code>mytype</code>).</p>
<p><code>X</code> has methods:</p>
<ul>
<li><code>CoordinateVector X.coordinates()</code>: CoordinateVector of the current site</li>
<li><code>int X.coordinate(Direction)</code>: coordinate to direction</li>
<li><code>Parity X.parity()</code>: parity of current site</li>
</ul>
<p>The assignment <code>f[ALL] = 2 + g[X];</code> can also be done with <code>f = 2 + g</code>. The main difference is in sequencing: the first form goes through the lattice sites in one <em>site loop</em>, whereas the second stores the result of 2 + g to a temporary field variable which is copied to f (in this case std::moved). The site loop form is faster since it minimizes temporaries and memory accesses. <br  />
</p>
<p>Because <code>f[X]</code> is of type field element, the methods defined for the element type can be used. <br  />
 <code>f[X].dagger()</code> is ok, <code>f.dagger()</code> is not.</p>
<p><code>f[X]</code> also serves as a visual identifier for a field variable access.</p>
<p><a class="el" href="classReduction.html">Reduction</a>:</p>
<div class="fragment"><div class="line">mytype d = 0;</div>
<div class="line">onsites(ALL) d += f[X] - g[X+e_x];</div>
<div class="line"> </div>
<div class="line">hila::out0 &lt;&lt; &quot;The reduction is &lt;&lt; d &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Other features:</p>
<div class="fragment"><div class="line">double a = 3, b = 5;</div>
<div class="line">Field&lt;double&gt; f, g=0;</div>
<div class="line"> </div>
<div class="line">onsites(ALL) {</div>
<div class="line">    f[X] = (a + b);            // ok, loop extern variables a,b do not change within the loop</div>
<div class="line">    b = f[X];                  // ERROR: cannot change a loop extern non-field variable (except reductions)</div>
<div class="line">    double c = sin(f[X]);      // ok, variable c defined within the loop</div>
<div class="line">    f[X] = c + g;              // ERROR: using field variable g without [X]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CoordinateVector v = {0,1,1,0};</div>
<div class="line"> </div>
<div class="line">f = g.shift(v);                // these two</div>
<div class="line">f[ALL] = g[X + v];             // are equivalent</div>
<div class="line"> </div>
<div class="line">f[EVEN] = g[X + v];            // Cannot be done with g.shift() alone</div>
</div><!-- fragment --><p>Access field at a single point: <code>f[CoordinateVector]</code>. This can be used only outside site loops.</p>
<div class="fragment"><div class="line">CoordinateVector v = {2,3,4,5};</div>
<div class="line">auto value = f[v];              // &quot;value&quot; is broadcast to all nodes!</div>
<div class="line">f[v] = 1;                       // In assignment, values are not broadcast: the node which</div>
<div class="line">                                // owns site v must have correct rhs.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md36"></a>
Input library</h2>
<p>Class hila::input can be used to read parameters and other data for simulation programs. It matches key-value pairs from input files. As an example, if the file <code>parameters.dat</code> contains</p>
<div class="fragment"><div class="line"># this is a comment</div>
<div class="line"># Run parameters for run XYZ</div>
<div class="line"> </div>
<div class="line">lattice size  64, 64, 64, 128</div>
<div class="line">beta          5.4</div>
<div class="line">clover        perturbative</div>
<div class="line"> </div>
<div class="line">loops         25000</div>
<div class="line">seed          3474212</div>
<div class="line"> </div>
<div class="line">coefficients    0.5, 0.7, 0.85, 1.3, 1.6, 2</div>
<div class="line">labels        setA, setB, setC</div>
</div><!-- fragment --><p>it can be read (mostly) using the method <code>input::get(std::string key)</code>:</p>
<div class="fragment"><div class="line">#include &quot;hila.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char * argv[]) {</div>
<div class="line"> </div>
<div class="line">    hila::initialize(argc,argv);</div>
<div class="line"> </div>
<div class="line">    // open file after hila::initialize</div>
<div class="line">    // here to variable p</div>
<div class="line">    hila::input p(&quot;parameters.dat&quot;);</div>
<div class="line"> </div>
<div class="line">    CoordinateVector lsize = p.get(&quot;lattice size&quot;);</div>
<div class="line">    double beta            = p.get(&quot;beta&quot;);</div>
<div class="line"> </div>
<div class="line">    // Calling get_item() as below means that allowed values for </div>
<div class="line">    // &quot;clover&quot; are:  &quot;tree&quot;, &quot;perturbative&quot;, or a float/double value.</div>
<div class="line">    // Return value is 0, 1, 2 respectively.</div>
<div class="line">    int i = p.get_item(&quot;clover&quot;,{&quot;tree&quot;,&quot;perturbative&quot;,&quot;%f&quot;});</div>
<div class="line">    double clover;</div>
<div class="line">    if (i == 0) </div>
<div class="line">        clover = 1;</div>
<div class="line">    else if (i == 1) </div>
<div class="line">        clover = &lt;perturbative expression&gt;;</div>
<div class="line">    else </div>
<div class="line">        clover = p.get();  // the number is read here without key argument</div>
<div class="line"> </div>
<div class="line">    int loops       = p.get(&quot;loops&quot;);</div>
<div class="line">    long rng_seed   = p.get(&quot;seed&quot;);</div>
<div class="line"> </div>
<div class="line">    // reading a std::vector&lt;&gt; reads in comma-separated values</div>
<div class="line">    // this reads in a vector of 6 doubles</div>
<div class="line">    std::vector&lt;double&gt; run_coefficients = p.get(&quot;coefficients&quot;);</div>
<div class="line"> </div>
<div class="line">    // and this a vector of 3 strings</div>
<div class="line">    std::vector&lt;std::string&gt; labels      = p.get(&quot;labels&quot;);</div>
<div class="line"> </div>
<div class="line">    // Close the file. File is also closed when p gets out of scope</div>
<div class="line">    p.close();   </div>
<div class="line"> </div>
<div class="line">    // lattice setup is convenient to do after parameters have been read</div>
<div class="line">    lattice.setup(lsize);</div>
</div><!-- fragment --><ul>
<li>The method <code>input::get()</code> above deduces the type to be read in from the expected return value. The order is fixed, the items (lines) cannot be swapped (TODO: should this be allowed?). If an error occurs (wrong keys or values), program exits with an error message.</li>
<li>Because the order is fixed, the keys don't really carry information for the program. However, they help to ensure that the values are as intended.</li>
<li>The method <code>input::get()</code> broadcasts the values to all nodes. They have to be called by all nodes simultaneously.</li>
<li>Method <code>input::get_value()</code> has more options for synchronization and error returns. See documentation in <code><a class="el" href="input_8h_source.html">input.h</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
Check input and layout</h2>
<p>The input files and the lattice layout can be checked with the commands (after the application program has been built) </p><div class="fragment"><div class="line">&lt;hila-program-name&gt; check</div>
<div class="line">&lt;hila-program-name&gt; check=&lt;number-of-nodes&gt;        # without spaces</div>
</div><!-- fragment --><p> This runs the program without initializing MPI, Cuda or other hardware features and exits at <code>lattice.setup()</code> before any large memory allocations are made. If the number-of-nodes argument is given, program reports how the node layout is done.</p>
<p>Example: if you built the <code>hila_example</code> program above, in directory <code>hila/applications/hila_example</code> the command <code>build/hila_example check=32</code> checks the input file and the layout to 32 nodes.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Stale Instructions</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Generating documentation</h2>
<p>Build the documentation (with the git hash as the version number) using </p><div class="fragment"><div class="line">PROJECT_NUMBER=$(git rev-parse --short HEAD) doxygen</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
Compiling the preprocessing tool and using it on c++ code</h2>
<p>In short, the framework can be used in these steps:</p>
<ol type="1">
<li>Write c++ code using the syntax and datatypes laid out below</li>
<li>Use the hilapp excecutable to convert this code into .cpt code</li>
<li>Compile the new .cpt code into the final excecutable</li>
</ol>
<p><img src="/docs/workflowV1.png" alt="Workflow illustration" class="inline"/></p>
<p>You can then use it to compile an extended C++ file into standard C++ using </p><div class="fragment"><div class="line">bin/hilapp path/to/program.cpp</div>
</div><!-- fragment --><p> This will create a <code>cpt</code> file written in standard C++.</p>
<p>The <code>cpt</code> can be compiled with any c++ compiler, but must be linked against the headers and c++ files in the plumbing directory.</p>
<p>Check the example programs in the programs folder. You can use almost any standard C++ code, by there are a couple of new reserved names: the variable <code>X</code> and the function <code>onsites()</code>. In addition the framework defines a global <code>lattice</code> variable, which you should not overwrite.</p>
<p>In order to use the additional features for field type variables, you should inlude <code><a class="el" href="field_8h.html">plumbing/field.h</a></code> in you program. You can also include one or more of the files in the <code>datatypes</code> folder, which contains predefined datatypes that can be used to construct a field. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
